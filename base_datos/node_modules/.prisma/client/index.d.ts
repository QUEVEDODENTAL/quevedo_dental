
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model Empleado
 * 
 */
export type Empleado = $Result.DefaultSelection<Prisma.$EmpleadoPayload>
/**
 * Model Clientes
 * 
 */
export type Clientes = $Result.DefaultSelection<Prisma.$ClientesPayload>
/**
 * Model Enfermedades
 * 
 */
export type Enfermedades = $Result.DefaultSelection<Prisma.$EnfermedadesPayload>
/**
 * Model AntecedentesNoPatologicos
 * 
 */
export type AntecedentesNoPatologicos = $Result.DefaultSelection<Prisma.$AntecedentesNoPatologicosPayload>
/**
 * Model AntecedentesPatologicos
 * 
 */
export type AntecedentesPatologicos = $Result.DefaultSelection<Prisma.$AntecedentesPatologicosPayload>
/**
 * Model ExamenClinicoIntraoral
 * 
 */
export type ExamenClinicoIntraoral = $Result.DefaultSelection<Prisma.$ExamenClinicoIntraoralPayload>
/**
 * Model HistorialClinico
 * 
 */
export type HistorialClinico = $Result.DefaultSelection<Prisma.$HistorialClinicoPayload>
/**
 * Model Permiso
 * 
 */
export type Permiso = $Result.DefaultSelection<Prisma.$PermisoPayload>
/**
 * Model Bitacora
 * 
 */
export type Bitacora = $Result.DefaultSelection<Prisma.$BitacoraPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const GeneroEnum: {
  Masculino: 'Masculino',
  Femenino: 'Femenino',
  Otro: 'Otro'
};

export type GeneroEnum = (typeof GeneroEnum)[keyof typeof GeneroEnum]


export const TipoEnfermedadEnum: {
  Cardiovasculares: 'Cardiovasculares',
  Hematologicas: 'Hematologicas',
  Neurologicas: 'Neurologicas',
  Pulmonares: 'Pulmonares',
  Endocrinas: 'Endocrinas',
  Metabolicas: 'Metabolicas',
  Renales: 'Renales',
  Mentales: 'Mentales',
  Gastrointestinales: 'Gastrointestinales',
  Dermatologicas: 'Dermatologicas',
  Cancer: 'Cancer',
  Otros: 'Otros',
  EnfermedadesDeLaInfancia: 'EnfermedadesDeLaInfancia'
};

export type TipoEnfermedadEnum = (typeof TipoEnfermedadEnum)[keyof typeof TipoEnfermedadEnum]


export const SiNoEnum: {
  Si: 'Si',
  No: 'No'
};

export type SiNoEnum = (typeof SiNoEnum)[keyof typeof SiNoEnum]

}

export type GeneroEnum = $Enums.GeneroEnum

export const GeneroEnum: typeof $Enums.GeneroEnum

export type TipoEnfermedadEnum = $Enums.TipoEnfermedadEnum

export const TipoEnfermedadEnum: typeof $Enums.TipoEnfermedadEnum

export type SiNoEnum = $Enums.SiNoEnum

export const SiNoEnum: typeof $Enums.SiNoEnum

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Doctors
 * const doctors = await prisma.doctor.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Doctors
   * const doctors = await prisma.doctor.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs>;

  /**
   * `prisma.empleado`: Exposes CRUD operations for the **Empleado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Empleados
    * const empleados = await prisma.empleado.findMany()
    * ```
    */
  get empleado(): Prisma.EmpleadoDelegate<ExtArgs>;

  /**
   * `prisma.clientes`: Exposes CRUD operations for the **Clientes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clientes
    * const clientes = await prisma.clientes.findMany()
    * ```
    */
  get clientes(): Prisma.ClientesDelegate<ExtArgs>;

  /**
   * `prisma.enfermedades`: Exposes CRUD operations for the **Enfermedades** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enfermedades
    * const enfermedades = await prisma.enfermedades.findMany()
    * ```
    */
  get enfermedades(): Prisma.EnfermedadesDelegate<ExtArgs>;

  /**
   * `prisma.antecedentesNoPatologicos`: Exposes CRUD operations for the **AntecedentesNoPatologicos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AntecedentesNoPatologicos
    * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findMany()
    * ```
    */
  get antecedentesNoPatologicos(): Prisma.AntecedentesNoPatologicosDelegate<ExtArgs>;

  /**
   * `prisma.antecedentesPatologicos`: Exposes CRUD operations for the **AntecedentesPatologicos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AntecedentesPatologicos
    * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findMany()
    * ```
    */
  get antecedentesPatologicos(): Prisma.AntecedentesPatologicosDelegate<ExtArgs>;

  /**
   * `prisma.examenClinicoIntraoral`: Exposes CRUD operations for the **ExamenClinicoIntraoral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExamenClinicoIntraorals
    * const examenClinicoIntraorals = await prisma.examenClinicoIntraoral.findMany()
    * ```
    */
  get examenClinicoIntraoral(): Prisma.ExamenClinicoIntraoralDelegate<ExtArgs>;

  /**
   * `prisma.historialClinico`: Exposes CRUD operations for the **HistorialClinico** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorialClinicos
    * const historialClinicos = await prisma.historialClinico.findMany()
    * ```
    */
  get historialClinico(): Prisma.HistorialClinicoDelegate<ExtArgs>;

  /**
   * `prisma.permiso`: Exposes CRUD operations for the **Permiso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permisos
    * const permisos = await prisma.permiso.findMany()
    * ```
    */
  get permiso(): Prisma.PermisoDelegate<ExtArgs>;

  /**
   * `prisma.bitacora`: Exposes CRUD operations for the **Bitacora** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bitacoras
    * const bitacoras = await prisma.bitacora.findMany()
    * ```
    */
  get bitacora(): Prisma.BitacoraDelegate<ExtArgs>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Doctor: 'Doctor',
    Empleado: 'Empleado',
    Clientes: 'Clientes',
    Enfermedades: 'Enfermedades',
    AntecedentesNoPatologicos: 'AntecedentesNoPatologicos',
    AntecedentesPatologicos: 'AntecedentesPatologicos',
    ExamenClinicoIntraoral: 'ExamenClinicoIntraoral',
    HistorialClinico: 'HistorialClinico',
    Permiso: 'Permiso',
    Bitacora: 'Bitacora',
    Usuarios: 'Usuarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'doctor' | 'empleado' | 'clientes' | 'enfermedades' | 'antecedentesNoPatologicos' | 'antecedentesPatologicos' | 'examenClinicoIntraoral' | 'historialClinico' | 'permiso' | 'bitacora' | 'usuarios'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>,
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>,
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      Empleado: {
        payload: Prisma.$EmpleadoPayload<ExtArgs>
        fields: Prisma.EmpleadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmpleadoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmpleadoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          findFirst: {
            args: Prisma.EmpleadoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmpleadoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          findMany: {
            args: Prisma.EmpleadoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>[]
          }
          create: {
            args: Prisma.EmpleadoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          createMany: {
            args: Prisma.EmpleadoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EmpleadoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          update: {
            args: Prisma.EmpleadoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          deleteMany: {
            args: Prisma.EmpleadoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EmpleadoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EmpleadoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EmpleadoPayload>
          }
          aggregate: {
            args: Prisma.EmpleadoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEmpleado>
          }
          groupBy: {
            args: Prisma.EmpleadoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EmpleadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmpleadoCountArgs<ExtArgs>,
            result: $Utils.Optional<EmpleadoCountAggregateOutputType> | number
          }
        }
      }
      Clientes: {
        payload: Prisma.$ClientesPayload<ExtArgs>
        fields: Prisma.ClientesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          findFirst: {
            args: Prisma.ClientesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          findMany: {
            args: Prisma.ClientesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>[]
          }
          create: {
            args: Prisma.ClientesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          createMany: {
            args: Prisma.ClientesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ClientesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          update: {
            args: Prisma.ClientesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          deleteMany: {
            args: Prisma.ClientesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ClientesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ClientesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ClientesPayload>
          }
          aggregate: {
            args: Prisma.ClientesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateClientes>
          }
          groupBy: {
            args: Prisma.ClientesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ClientesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientesCountArgs<ExtArgs>,
            result: $Utils.Optional<ClientesCountAggregateOutputType> | number
          }
        }
      }
      Enfermedades: {
        payload: Prisma.$EnfermedadesPayload<ExtArgs>
        fields: Prisma.EnfermedadesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EnfermedadesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EnfermedadesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          findFirst: {
            args: Prisma.EnfermedadesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EnfermedadesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          findMany: {
            args: Prisma.EnfermedadesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>[]
          }
          create: {
            args: Prisma.EnfermedadesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          createMany: {
            args: Prisma.EnfermedadesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.EnfermedadesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          update: {
            args: Prisma.EnfermedadesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          deleteMany: {
            args: Prisma.EnfermedadesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.EnfermedadesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.EnfermedadesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$EnfermedadesPayload>
          }
          aggregate: {
            args: Prisma.EnfermedadesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateEnfermedades>
          }
          groupBy: {
            args: Prisma.EnfermedadesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<EnfermedadesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EnfermedadesCountArgs<ExtArgs>,
            result: $Utils.Optional<EnfermedadesCountAggregateOutputType> | number
          }
        }
      }
      AntecedentesNoPatologicos: {
        payload: Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>
        fields: Prisma.AntecedentesNoPatologicosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AntecedentesNoPatologicosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AntecedentesNoPatologicosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          findFirst: {
            args: Prisma.AntecedentesNoPatologicosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AntecedentesNoPatologicosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          findMany: {
            args: Prisma.AntecedentesNoPatologicosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>[]
          }
          create: {
            args: Prisma.AntecedentesNoPatologicosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          createMany: {
            args: Prisma.AntecedentesNoPatologicosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AntecedentesNoPatologicosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          update: {
            args: Prisma.AntecedentesNoPatologicosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          deleteMany: {
            args: Prisma.AntecedentesNoPatologicosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AntecedentesNoPatologicosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AntecedentesNoPatologicosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesNoPatologicosPayload>
          }
          aggregate: {
            args: Prisma.AntecedentesNoPatologicosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAntecedentesNoPatologicos>
          }
          groupBy: {
            args: Prisma.AntecedentesNoPatologicosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AntecedentesNoPatologicosGroupByOutputType>[]
          }
          count: {
            args: Prisma.AntecedentesNoPatologicosCountArgs<ExtArgs>,
            result: $Utils.Optional<AntecedentesNoPatologicosCountAggregateOutputType> | number
          }
        }
      }
      AntecedentesPatologicos: {
        payload: Prisma.$AntecedentesPatologicosPayload<ExtArgs>
        fields: Prisma.AntecedentesPatologicosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AntecedentesPatologicosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AntecedentesPatologicosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          findFirst: {
            args: Prisma.AntecedentesPatologicosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AntecedentesPatologicosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          findMany: {
            args: Prisma.AntecedentesPatologicosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>[]
          }
          create: {
            args: Prisma.AntecedentesPatologicosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          createMany: {
            args: Prisma.AntecedentesPatologicosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AntecedentesPatologicosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          update: {
            args: Prisma.AntecedentesPatologicosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          deleteMany: {
            args: Prisma.AntecedentesPatologicosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AntecedentesPatologicosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AntecedentesPatologicosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AntecedentesPatologicosPayload>
          }
          aggregate: {
            args: Prisma.AntecedentesPatologicosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAntecedentesPatologicos>
          }
          groupBy: {
            args: Prisma.AntecedentesPatologicosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AntecedentesPatologicosGroupByOutputType>[]
          }
          count: {
            args: Prisma.AntecedentesPatologicosCountArgs<ExtArgs>,
            result: $Utils.Optional<AntecedentesPatologicosCountAggregateOutputType> | number
          }
        }
      }
      ExamenClinicoIntraoral: {
        payload: Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>
        fields: Prisma.ExamenClinicoIntraoralFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamenClinicoIntraoralFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamenClinicoIntraoralFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          findFirst: {
            args: Prisma.ExamenClinicoIntraoralFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamenClinicoIntraoralFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          findMany: {
            args: Prisma.ExamenClinicoIntraoralFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>[]
          }
          create: {
            args: Prisma.ExamenClinicoIntraoralCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          createMany: {
            args: Prisma.ExamenClinicoIntraoralCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ExamenClinicoIntraoralDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          update: {
            args: Prisma.ExamenClinicoIntraoralUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          deleteMany: {
            args: Prisma.ExamenClinicoIntraoralDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ExamenClinicoIntraoralUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ExamenClinicoIntraoralUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ExamenClinicoIntraoralPayload>
          }
          aggregate: {
            args: Prisma.ExamenClinicoIntraoralAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateExamenClinicoIntraoral>
          }
          groupBy: {
            args: Prisma.ExamenClinicoIntraoralGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ExamenClinicoIntraoralGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamenClinicoIntraoralCountArgs<ExtArgs>,
            result: $Utils.Optional<ExamenClinicoIntraoralCountAggregateOutputType> | number
          }
        }
      }
      HistorialClinico: {
        payload: Prisma.$HistorialClinicoPayload<ExtArgs>
        fields: Prisma.HistorialClinicoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialClinicoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialClinicoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          findFirst: {
            args: Prisma.HistorialClinicoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialClinicoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          findMany: {
            args: Prisma.HistorialClinicoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>[]
          }
          create: {
            args: Prisma.HistorialClinicoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          createMany: {
            args: Prisma.HistorialClinicoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.HistorialClinicoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          update: {
            args: Prisma.HistorialClinicoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          deleteMany: {
            args: Prisma.HistorialClinicoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialClinicoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.HistorialClinicoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$HistorialClinicoPayload>
          }
          aggregate: {
            args: Prisma.HistorialClinicoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHistorialClinico>
          }
          groupBy: {
            args: Prisma.HistorialClinicoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HistorialClinicoGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialClinicoCountArgs<ExtArgs>,
            result: $Utils.Optional<HistorialClinicoCountAggregateOutputType> | number
          }
        }
      }
      Permiso: {
        payload: Prisma.$PermisoPayload<ExtArgs>
        fields: Prisma.PermisoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermisoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermisoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findFirst: {
            args: Prisma.PermisoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermisoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          findMany: {
            args: Prisma.PermisoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>[]
          }
          create: {
            args: Prisma.PermisoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          createMany: {
            args: Prisma.PermisoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PermisoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          update: {
            args: Prisma.PermisoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          deleteMany: {
            args: Prisma.PermisoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PermisoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PermisoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PermisoPayload>
          }
          aggregate: {
            args: Prisma.PermisoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePermiso>
          }
          groupBy: {
            args: Prisma.PermisoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PermisoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermisoCountArgs<ExtArgs>,
            result: $Utils.Optional<PermisoCountAggregateOutputType> | number
          }
        }
      }
      Bitacora: {
        payload: Prisma.$BitacoraPayload<ExtArgs>
        fields: Prisma.BitacoraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BitacoraFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BitacoraFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          findFirst: {
            args: Prisma.BitacoraFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BitacoraFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          findMany: {
            args: Prisma.BitacoraFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>[]
          }
          create: {
            args: Prisma.BitacoraCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          createMany: {
            args: Prisma.BitacoraCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.BitacoraDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          update: {
            args: Prisma.BitacoraUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          deleteMany: {
            args: Prisma.BitacoraDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.BitacoraUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.BitacoraUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$BitacoraPayload>
          }
          aggregate: {
            args: Prisma.BitacoraAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateBitacora>
          }
          groupBy: {
            args: Prisma.BitacoraGroupByArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraGroupByOutputType>[]
          }
          count: {
            args: Prisma.BitacoraCountArgs<ExtArgs>,
            result: $Utils.Optional<BitacoraCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>,
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    historiales_clinicos: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historiales_clinicos?: boolean | DoctorCountOutputTypeCountHistoriales_clinicosArgs
  }

  // Custom InputTypes

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountHistoriales_clinicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialClinicoWhereInput
  }



  /**
   * Count Type ClientesCountOutputType
   */

  export type ClientesCountOutputType = {
    historial_clinico: number
    antecedentesNoPatologicos: number
    antecedentesPatologicos: number
    examenesClinicosIntraorales: number
  }

  export type ClientesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historial_clinico?: boolean | ClientesCountOutputTypeCountHistorial_clinicoArgs
    antecedentesNoPatologicos?: boolean | ClientesCountOutputTypeCountAntecedentesNoPatologicosArgs
    antecedentesPatologicos?: boolean | ClientesCountOutputTypeCountAntecedentesPatologicosArgs
    examenesClinicosIntraorales?: boolean | ClientesCountOutputTypeCountExamenesClinicosIntraoralesArgs
  }

  // Custom InputTypes

  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientesCountOutputType
     */
    select?: ClientesCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountHistorial_clinicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialClinicoWhereInput
  }


  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountAntecedentesNoPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentesNoPatologicosWhereInput
  }


  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountAntecedentesPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentesPatologicosWhereInput
  }


  /**
   * ClientesCountOutputType without action
   */
  export type ClientesCountOutputTypeCountExamenesClinicosIntraoralesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenClinicoIntraoralWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type DoctorSumAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type DoctorMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    especialidad: string | null
    direccion: string | null
    telefono: string | null
    celular: string | null
    curp: string | null
    cedula: string | null
    sexo: string | null
    licencia_medica: string | null
    correo_electronico: string | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    especialidad: string | null
    direccion: string | null
    telefono: string | null
    celular: string | null
    curp: string | null
    cedula: string | null
    sexo: string | null
    licencia_medica: string | null
    correo_electronico: string | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    edad: number
    fecha_nacimiento: number
    genero: number
    especialidad: number
    direccion: number
    telefono: number
    celular: number
    curp: number
    cedula: number
    sexo: number
    licencia_medica: number
    correo_electronico: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    id?: true
    edad?: true
  }

  export type DoctorSumAggregateInputType = {
    id?: true
    edad?: true
  }

  export type DoctorMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edad?: true
    fecha_nacimiento?: true
    genero?: true
    especialidad?: true
    direccion?: true
    telefono?: true
    celular?: true
    curp?: true
    cedula?: true
    sexo?: true
    licencia_medica?: true
    correo_electronico?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edad?: true
    fecha_nacimiento?: true
    genero?: true
    especialidad?: true
    direccion?: true
    telefono?: true
    celular?: true
    curp?: true
    cedula?: true
    sexo?: true
    licencia_medica?: true
    correo_electronico?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    edad?: true
    fecha_nacimiento?: true
    genero?: true
    especialidad?: true
    direccion?: true
    telefono?: true
    celular?: true
    curp?: true
    cedula?: true
    sexo?: true
    licencia_medica?: true
    correo_electronico?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    edad: number | null
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    especialidad: string | null
    direccion: string | null
    telefono: string | null
    celular: string | null
    curp: string | null
    cedula: string | null
    sexo: string | null
    licencia_medica: string | null
    correo_electronico: string | null
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    genero?: boolean
    especialidad?: boolean
    direccion?: boolean
    telefono?: boolean
    celular?: boolean
    curp?: boolean
    cedula?: boolean
    sexo?: boolean
    licencia_medica?: boolean
    correo_electronico?: boolean
    historiales_clinicos?: boolean | Doctor$historiales_clinicosArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    genero?: boolean
    especialidad?: boolean
    direccion?: boolean
    telefono?: boolean
    celular?: boolean
    curp?: boolean
    cedula?: boolean
    sexo?: boolean
    licencia_medica?: boolean
    correo_electronico?: boolean
  }

  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historiales_clinicos?: boolean | Doctor$historiales_clinicosArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      historiales_clinicos: Prisma.$HistorialClinicoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      edad: number | null
      fecha_nacimiento: Date | null
      genero: $Enums.GeneroEnum | null
      especialidad: string | null
      direccion: string | null
      telefono: string | null
      celular: string | null
      curp: string | null
      cedula: string | null
      sexo: string | null
      licencia_medica: string | null
      correo_electronico: string | null
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }


  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends DoctorFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Doctor that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends DoctorFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends DoctorFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
    **/
    create<T extends DoctorCreateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Doctors.
     *     @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     *     @example
     *     // Create many Doctors
     *     const doctor = await prisma.doctor.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends DoctorCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
    **/
    delete<T extends DoctorDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends DoctorUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends DoctorDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends DoctorUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
    **/
    upsert<T extends DoctorUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>
    ): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    historiales_clinicos<T extends Doctor$historiales_clinicosArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$historiales_clinicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Doctor model
   */ 
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'Int'>
    readonly nombre: FieldRef<"Doctor", 'String'>
    readonly apellido: FieldRef<"Doctor", 'String'>
    readonly edad: FieldRef<"Doctor", 'Int'>
    readonly fecha_nacimiento: FieldRef<"Doctor", 'DateTime'>
    readonly genero: FieldRef<"Doctor", 'GeneroEnum'>
    readonly especialidad: FieldRef<"Doctor", 'String'>
    readonly direccion: FieldRef<"Doctor", 'String'>
    readonly telefono: FieldRef<"Doctor", 'String'>
    readonly celular: FieldRef<"Doctor", 'String'>
    readonly curp: FieldRef<"Doctor", 'String'>
    readonly cedula: FieldRef<"Doctor", 'String'>
    readonly sexo: FieldRef<"Doctor", 'String'>
    readonly licencia_medica: FieldRef<"Doctor", 'String'>
    readonly correo_electronico: FieldRef<"Doctor", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }


  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }


  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }


  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }


  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }


  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }


  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
  }


  /**
   * Doctor.historiales_clinicos
   */
  export type Doctor$historiales_clinicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    where?: HistorialClinicoWhereInput
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    cursor?: HistorialClinicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialClinicoScalarFieldEnum | HistorialClinicoScalarFieldEnum[]
  }


  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: DoctorInclude<ExtArgs> | null
  }



  /**
   * Model Empleado
   */

  export type AggregateEmpleado = {
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  export type EmpleadoAvgAggregateOutputType = {
    id: number | null
    salario: number | null
  }

  export type EmpleadoSumAggregateOutputType = {
    id: number | null
    salario: number | null
  }

  export type EmpleadoMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    telefono: string | null
    correo_electronico: string | null
    direccion: string | null
    puesto: string | null
    curp: string | null
    rfc: string | null
    salario: number | null
    fecha_contratacion: Date | null
  }

  export type EmpleadoMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    telefono: string | null
    correo_electronico: string | null
    direccion: string | null
    puesto: string | null
    curp: string | null
    rfc: string | null
    salario: number | null
    fecha_contratacion: Date | null
  }

  export type EmpleadoCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    fecha_nacimiento: number
    genero: number
    telefono: number
    correo_electronico: number
    direccion: number
    puesto: number
    curp: number
    rfc: number
    salario: number
    fecha_contratacion: number
    _all: number
  }


  export type EmpleadoAvgAggregateInputType = {
    id?: true
    salario?: true
  }

  export type EmpleadoSumAggregateInputType = {
    id?: true
    salario?: true
  }

  export type EmpleadoMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    fecha_nacimiento?: true
    genero?: true
    telefono?: true
    correo_electronico?: true
    direccion?: true
    puesto?: true
    curp?: true
    rfc?: true
    salario?: true
    fecha_contratacion?: true
  }

  export type EmpleadoMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    fecha_nacimiento?: true
    genero?: true
    telefono?: true
    correo_electronico?: true
    direccion?: true
    puesto?: true
    curp?: true
    rfc?: true
    salario?: true
    fecha_contratacion?: true
  }

  export type EmpleadoCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    fecha_nacimiento?: true
    genero?: true
    telefono?: true
    correo_electronico?: true
    direccion?: true
    puesto?: true
    curp?: true
    rfc?: true
    salario?: true
    fecha_contratacion?: true
    _all?: true
  }

  export type EmpleadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleado to aggregate.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Empleados
    **/
    _count?: true | EmpleadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmpleadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmpleadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmpleadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmpleadoMaxAggregateInputType
  }

  export type GetEmpleadoAggregateType<T extends EmpleadoAggregateArgs> = {
        [P in keyof T & keyof AggregateEmpleado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmpleado[P]>
      : GetScalarType<T[P], AggregateEmpleado[P]>
  }




  export type EmpleadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmpleadoWhereInput
    orderBy?: EmpleadoOrderByWithAggregationInput | EmpleadoOrderByWithAggregationInput[]
    by: EmpleadoScalarFieldEnum[] | EmpleadoScalarFieldEnum
    having?: EmpleadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmpleadoCountAggregateInputType | true
    _avg?: EmpleadoAvgAggregateInputType
    _sum?: EmpleadoSumAggregateInputType
    _min?: EmpleadoMinAggregateInputType
    _max?: EmpleadoMaxAggregateInputType
  }

  export type EmpleadoGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    fecha_nacimiento: Date | null
    genero: $Enums.GeneroEnum | null
    telefono: string | null
    correo_electronico: string | null
    direccion: string | null
    puesto: string | null
    curp: string | null
    rfc: string | null
    salario: number | null
    fecha_contratacion: Date | null
    _count: EmpleadoCountAggregateOutputType | null
    _avg: EmpleadoAvgAggregateOutputType | null
    _sum: EmpleadoSumAggregateOutputType | null
    _min: EmpleadoMinAggregateOutputType | null
    _max: EmpleadoMaxAggregateOutputType | null
  }

  type GetEmpleadoGroupByPayload<T extends EmpleadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmpleadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmpleadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
            : GetScalarType<T[P], EmpleadoGroupByOutputType[P]>
        }
      >
    >


  export type EmpleadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    fecha_nacimiento?: boolean
    genero?: boolean
    telefono?: boolean
    correo_electronico?: boolean
    direccion?: boolean
    puesto?: boolean
    curp?: boolean
    rfc?: boolean
    salario?: boolean
    fecha_contratacion?: boolean
  }, ExtArgs["result"]["empleado"]>

  export type EmpleadoSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    fecha_nacimiento?: boolean
    genero?: boolean
    telefono?: boolean
    correo_electronico?: boolean
    direccion?: boolean
    puesto?: boolean
    curp?: boolean
    rfc?: boolean
    salario?: boolean
    fecha_contratacion?: boolean
  }


  export type $EmpleadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Empleado"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      fecha_nacimiento: Date | null
      genero: $Enums.GeneroEnum | null
      telefono: string | null
      correo_electronico: string | null
      direccion: string | null
      puesto: string | null
      curp: string | null
      rfc: string | null
      salario: number | null
      fecha_contratacion: Date | null
    }, ExtArgs["result"]["empleado"]>
    composites: {}
  }


  type EmpleadoGetPayload<S extends boolean | null | undefined | EmpleadoDefaultArgs> = $Result.GetResult<Prisma.$EmpleadoPayload, S>

  type EmpleadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmpleadoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmpleadoCountAggregateInputType | true
    }

  export interface EmpleadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Empleado'], meta: { name: 'Empleado' } }
    /**
     * Find zero or one Empleado that matches the filter.
     * @param {EmpleadoFindUniqueArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EmpleadoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoFindUniqueArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Empleado that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EmpleadoFindUniqueOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EmpleadoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Empleado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindFirstArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EmpleadoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoFindFirstArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Empleado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindFirstOrThrowArgs} args - Arguments to find a Empleado
     * @example
     * // Get one Empleado
     * const empleado = await prisma.empleado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EmpleadoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Empleados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Empleados
     * const empleados = await prisma.empleado.findMany()
     * 
     * // Get first 10 Empleados
     * const empleados = await prisma.empleado.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const empleadoWithIdOnly = await prisma.empleado.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EmpleadoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Empleado.
     * @param {EmpleadoCreateArgs} args - Arguments to create a Empleado.
     * @example
     * // Create one Empleado
     * const Empleado = await prisma.empleado.create({
     *   data: {
     *     // ... data to create a Empleado
     *   }
     * })
     * 
    **/
    create<T extends EmpleadoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoCreateArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Empleados.
     *     @param {EmpleadoCreateManyArgs} args - Arguments to create many Empleados.
     *     @example
     *     // Create many Empleados
     *     const empleado = await prisma.empleado.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EmpleadoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Empleado.
     * @param {EmpleadoDeleteArgs} args - Arguments to delete one Empleado.
     * @example
     * // Delete one Empleado
     * const Empleado = await prisma.empleado.delete({
     *   where: {
     *     // ... filter to delete one Empleado
     *   }
     * })
     * 
    **/
    delete<T extends EmpleadoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoDeleteArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Empleado.
     * @param {EmpleadoUpdateArgs} args - Arguments to update one Empleado.
     * @example
     * // Update one Empleado
     * const empleado = await prisma.empleado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EmpleadoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoUpdateArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Empleados.
     * @param {EmpleadoDeleteManyArgs} args - Arguments to filter Empleados to delete.
     * @example
     * // Delete a few Empleados
     * const { count } = await prisma.empleado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EmpleadoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EmpleadoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Empleados
     * const empleado = await prisma.empleado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EmpleadoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Empleado.
     * @param {EmpleadoUpsertArgs} args - Arguments to update or create a Empleado.
     * @example
     * // Update or create a Empleado
     * const empleado = await prisma.empleado.upsert({
     *   create: {
     *     // ... data to create a Empleado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Empleado we want to update
     *   }
     * })
    **/
    upsert<T extends EmpleadoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EmpleadoUpsertArgs<ExtArgs>>
    ): Prisma__EmpleadoClient<$Result.GetResult<Prisma.$EmpleadoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Empleados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoCountArgs} args - Arguments to filter Empleados to count.
     * @example
     * // Count the number of Empleados
     * const count = await prisma.empleado.count({
     *   where: {
     *     // ... the filter for the Empleados we want to count
     *   }
     * })
    **/
    count<T extends EmpleadoCountArgs>(
      args?: Subset<T, EmpleadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmpleadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmpleadoAggregateArgs>(args: Subset<T, EmpleadoAggregateArgs>): Prisma.PrismaPromise<GetEmpleadoAggregateType<T>>

    /**
     * Group by Empleado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmpleadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmpleadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmpleadoGroupByArgs['orderBy'] }
        : { orderBy?: EmpleadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmpleadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmpleadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Empleado model
   */
  readonly fields: EmpleadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Empleado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmpleadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Empleado model
   */ 
  interface EmpleadoFieldRefs {
    readonly id: FieldRef<"Empleado", 'Int'>
    readonly nombre: FieldRef<"Empleado", 'String'>
    readonly apellido: FieldRef<"Empleado", 'String'>
    readonly fecha_nacimiento: FieldRef<"Empleado", 'DateTime'>
    readonly genero: FieldRef<"Empleado", 'GeneroEnum'>
    readonly telefono: FieldRef<"Empleado", 'String'>
    readonly correo_electronico: FieldRef<"Empleado", 'String'>
    readonly direccion: FieldRef<"Empleado", 'String'>
    readonly puesto: FieldRef<"Empleado", 'String'>
    readonly curp: FieldRef<"Empleado", 'String'>
    readonly rfc: FieldRef<"Empleado", 'String'>
    readonly salario: FieldRef<"Empleado", 'Float'>
    readonly fecha_contratacion: FieldRef<"Empleado", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Empleado findUnique
   */
  export type EmpleadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where: EmpleadoWhereUniqueInput
  }


  /**
   * Empleado findUniqueOrThrow
   */
  export type EmpleadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where: EmpleadoWhereUniqueInput
  }


  /**
   * Empleado findFirst
   */
  export type EmpleadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * Empleado findFirstOrThrow
   */
  export type EmpleadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter, which Empleado to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Empleados.
     */
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * Empleado findMany
   */
  export type EmpleadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter, which Empleados to fetch.
     */
    where?: EmpleadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Empleados to fetch.
     */
    orderBy?: EmpleadoOrderByWithRelationInput | EmpleadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Empleados.
     */
    cursor?: EmpleadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Empleados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Empleados.
     */
    skip?: number
    distinct?: EmpleadoScalarFieldEnum | EmpleadoScalarFieldEnum[]
  }


  /**
   * Empleado create
   */
  export type EmpleadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * The data needed to create a Empleado.
     */
    data: XOR<EmpleadoCreateInput, EmpleadoUncheckedCreateInput>
  }


  /**
   * Empleado createMany
   */
  export type EmpleadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Empleados.
     */
    data: EmpleadoCreateManyInput | EmpleadoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Empleado update
   */
  export type EmpleadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * The data needed to update a Empleado.
     */
    data: XOR<EmpleadoUpdateInput, EmpleadoUncheckedUpdateInput>
    /**
     * Choose, which Empleado to update.
     */
    where: EmpleadoWhereUniqueInput
  }


  /**
   * Empleado updateMany
   */
  export type EmpleadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Empleados.
     */
    data: XOR<EmpleadoUpdateManyMutationInput, EmpleadoUncheckedUpdateManyInput>
    /**
     * Filter which Empleados to update
     */
    where?: EmpleadoWhereInput
  }


  /**
   * Empleado upsert
   */
  export type EmpleadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * The filter to search for the Empleado to update in case it exists.
     */
    where: EmpleadoWhereUniqueInput
    /**
     * In case the Empleado found by the `where` argument doesn't exist, create a new Empleado with this data.
     */
    create: XOR<EmpleadoCreateInput, EmpleadoUncheckedCreateInput>
    /**
     * In case the Empleado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmpleadoUpdateInput, EmpleadoUncheckedUpdateInput>
  }


  /**
   * Empleado delete
   */
  export type EmpleadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
    /**
     * Filter which Empleado to delete.
     */
    where: EmpleadoWhereUniqueInput
  }


  /**
   * Empleado deleteMany
   */
  export type EmpleadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Empleados to delete
     */
    where?: EmpleadoWhereInput
  }


  /**
   * Empleado without action
   */
  export type EmpleadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Empleado
     */
    select?: EmpleadoSelect<ExtArgs> | null
  }



  /**
   * Model Clientes
   */

  export type AggregateClientes = {
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  export type ClientesAvgAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type ClientesSumAggregateOutputType = {
    id: number | null
    edad: number | null
  }

  export type ClientesMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    sexo: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    domicilio: string | null
    telefono: string | null
    curp: string | null
    correo_electronico: string | null
    tipo_sangre: string | null
    ocupacion: string | null
    escolaridad: string | null
  }

  export type ClientesMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    apellido: string | null
    sexo: string | null
    edad: number | null
    fecha_nacimiento: Date | null
    domicilio: string | null
    telefono: string | null
    curp: string | null
    correo_electronico: string | null
    tipo_sangre: string | null
    ocupacion: string | null
    escolaridad: string | null
  }

  export type ClientesCountAggregateOutputType = {
    id: number
    nombre: number
    apellido: number
    sexo: number
    edad: number
    fecha_nacimiento: number
    domicilio: number
    telefono: number
    curp: number
    correo_electronico: number
    tipo_sangre: number
    ocupacion: number
    escolaridad: number
    _all: number
  }


  export type ClientesAvgAggregateInputType = {
    id?: true
    edad?: true
  }

  export type ClientesSumAggregateInputType = {
    id?: true
    edad?: true
  }

  export type ClientesMinAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    sexo?: true
    edad?: true
    fecha_nacimiento?: true
    domicilio?: true
    telefono?: true
    curp?: true
    correo_electronico?: true
    tipo_sangre?: true
    ocupacion?: true
    escolaridad?: true
  }

  export type ClientesMaxAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    sexo?: true
    edad?: true
    fecha_nacimiento?: true
    domicilio?: true
    telefono?: true
    curp?: true
    correo_electronico?: true
    tipo_sangre?: true
    ocupacion?: true
    escolaridad?: true
  }

  export type ClientesCountAggregateInputType = {
    id?: true
    nombre?: true
    apellido?: true
    sexo?: true
    edad?: true
    fecha_nacimiento?: true
    domicilio?: true
    telefono?: true
    curp?: true
    correo_electronico?: true
    tipo_sangre?: true
    ocupacion?: true
    escolaridad?: true
    _all?: true
  }

  export type ClientesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to aggregate.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clientes
    **/
    _count?: true | ClientesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientesMaxAggregateInputType
  }

  export type GetClientesAggregateType<T extends ClientesAggregateArgs> = {
        [P in keyof T & keyof AggregateClientes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientes[P]>
      : GetScalarType<T[P], AggregateClientes[P]>
  }




  export type ClientesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientesWhereInput
    orderBy?: ClientesOrderByWithAggregationInput | ClientesOrderByWithAggregationInput[]
    by: ClientesScalarFieldEnum[] | ClientesScalarFieldEnum
    having?: ClientesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientesCountAggregateInputType | true
    _avg?: ClientesAvgAggregateInputType
    _sum?: ClientesSumAggregateInputType
    _min?: ClientesMinAggregateInputType
    _max?: ClientesMaxAggregateInputType
  }

  export type ClientesGroupByOutputType = {
    id: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento: Date | null
    domicilio: string | null
    telefono: string | null
    curp: string
    correo_electronico: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    _count: ClientesCountAggregateOutputType | null
    _avg: ClientesAvgAggregateOutputType | null
    _sum: ClientesSumAggregateOutputType | null
    _min: ClientesMinAggregateOutputType | null
    _max: ClientesMaxAggregateOutputType | null
  }

  type GetClientesGroupByPayload<T extends ClientesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientesGroupByOutputType[P]>
            : GetScalarType<T[P], ClientesGroupByOutputType[P]>
        }
      >
    >


  export type ClientesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    sexo?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    domicilio?: boolean
    telefono?: boolean
    curp?: boolean
    correo_electronico?: boolean
    tipo_sangre?: boolean
    ocupacion?: boolean
    escolaridad?: boolean
    historial_clinico?: boolean | Clientes$historial_clinicoArgs<ExtArgs>
    antecedentesNoPatologicos?: boolean | Clientes$antecedentesNoPatologicosArgs<ExtArgs>
    antecedentesPatologicos?: boolean | Clientes$antecedentesPatologicosArgs<ExtArgs>
    examenesClinicosIntraorales?: boolean | Clientes$examenesClinicosIntraoralesArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientes"]>

  export type ClientesSelectScalar = {
    id?: boolean
    nombre?: boolean
    apellido?: boolean
    sexo?: boolean
    edad?: boolean
    fecha_nacimiento?: boolean
    domicilio?: boolean
    telefono?: boolean
    curp?: boolean
    correo_electronico?: boolean
    tipo_sangre?: boolean
    ocupacion?: boolean
    escolaridad?: boolean
  }

  export type ClientesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    historial_clinico?: boolean | Clientes$historial_clinicoArgs<ExtArgs>
    antecedentesNoPatologicos?: boolean | Clientes$antecedentesNoPatologicosArgs<ExtArgs>
    antecedentesPatologicos?: boolean | Clientes$antecedentesPatologicosArgs<ExtArgs>
    examenesClinicosIntraorales?: boolean | Clientes$examenesClinicosIntraoralesArgs<ExtArgs>
    _count?: boolean | ClientesCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ClientesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clientes"
    objects: {
      historial_clinico: Prisma.$HistorialClinicoPayload<ExtArgs>[]
      antecedentesNoPatologicos: Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>[]
      antecedentesPatologicos: Prisma.$AntecedentesPatologicosPayload<ExtArgs>[]
      examenesClinicosIntraorales: Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      apellido: string
      sexo: string
      edad: number
      fecha_nacimiento: Date | null
      domicilio: string | null
      telefono: string | null
      curp: string
      correo_electronico: string | null
      tipo_sangre: string
      ocupacion: string
      escolaridad: string
    }, ExtArgs["result"]["clientes"]>
    composites: {}
  }


  type ClientesGetPayload<S extends boolean | null | undefined | ClientesDefaultArgs> = $Result.GetResult<Prisma.$ClientesPayload, S>

  type ClientesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientesCountAggregateInputType | true
    }

  export interface ClientesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clientes'], meta: { name: 'Clientes' } }
    /**
     * Find zero or one Clientes that matches the filter.
     * @param {ClientesFindUniqueArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ClientesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesFindUniqueArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Clientes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ClientesFindUniqueOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ClientesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindFirstArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ClientesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesFindFirstArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Clientes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindFirstOrThrowArgs} args - Arguments to find a Clientes
     * @example
     * // Get one Clientes
     * const clientes = await prisma.clientes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ClientesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Clientes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clientes
     * const clientes = await prisma.clientes.findMany()
     * 
     * // Get first 10 Clientes
     * const clientes = await prisma.clientes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientesWithIdOnly = await prisma.clientes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ClientesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Clientes.
     * @param {ClientesCreateArgs} args - Arguments to create a Clientes.
     * @example
     * // Create one Clientes
     * const Clientes = await prisma.clientes.create({
     *   data: {
     *     // ... data to create a Clientes
     *   }
     * })
     * 
    **/
    create<T extends ClientesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesCreateArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Clientes.
     *     @param {ClientesCreateManyArgs} args - Arguments to create many Clientes.
     *     @example
     *     // Create many Clientes
     *     const clientes = await prisma.clientes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ClientesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clientes.
     * @param {ClientesDeleteArgs} args - Arguments to delete one Clientes.
     * @example
     * // Delete one Clientes
     * const Clientes = await prisma.clientes.delete({
     *   where: {
     *     // ... filter to delete one Clientes
     *   }
     * })
     * 
    **/
    delete<T extends ClientesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesDeleteArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Clientes.
     * @param {ClientesUpdateArgs} args - Arguments to update one Clientes.
     * @example
     * // Update one Clientes
     * const clientes = await prisma.clientes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ClientesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesUpdateArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Clientes.
     * @param {ClientesDeleteManyArgs} args - Arguments to filter Clientes to delete.
     * @example
     * // Delete a few Clientes
     * const { count } = await prisma.clientes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ClientesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ClientesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clientes
     * const clientes = await prisma.clientes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ClientesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clientes.
     * @param {ClientesUpsertArgs} args - Arguments to update or create a Clientes.
     * @example
     * // Update or create a Clientes
     * const clientes = await prisma.clientes.upsert({
     *   create: {
     *     // ... data to create a Clientes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clientes we want to update
     *   }
     * })
    **/
    upsert<T extends ClientesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ClientesUpsertArgs<ExtArgs>>
    ): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesCountArgs} args - Arguments to filter Clientes to count.
     * @example
     * // Count the number of Clientes
     * const count = await prisma.clientes.count({
     *   where: {
     *     // ... the filter for the Clientes we want to count
     *   }
     * })
    **/
    count<T extends ClientesCountArgs>(
      args?: Subset<T, ClientesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientesAggregateArgs>(args: Subset<T, ClientesAggregateArgs>): Prisma.PrismaPromise<GetClientesAggregateType<T>>

    /**
     * Group by Clientes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientesGroupByArgs['orderBy'] }
        : { orderBy?: ClientesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clientes model
   */
  readonly fields: ClientesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clientes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    historial_clinico<T extends Clientes$historial_clinicoArgs<ExtArgs> = {}>(args?: Subset<T, Clientes$historial_clinicoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findMany'> | Null>;

    antecedentesNoPatologicos<T extends Clientes$antecedentesNoPatologicosArgs<ExtArgs> = {}>(args?: Subset<T, Clientes$antecedentesNoPatologicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findMany'> | Null>;

    antecedentesPatologicos<T extends Clientes$antecedentesPatologicosArgs<ExtArgs> = {}>(args?: Subset<T, Clientes$antecedentesPatologicosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findMany'> | Null>;

    examenesClinicosIntraorales<T extends Clientes$examenesClinicosIntraoralesArgs<ExtArgs> = {}>(args?: Subset<T, Clientes$examenesClinicosIntraoralesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Clientes model
   */ 
  interface ClientesFieldRefs {
    readonly id: FieldRef<"Clientes", 'Int'>
    readonly nombre: FieldRef<"Clientes", 'String'>
    readonly apellido: FieldRef<"Clientes", 'String'>
    readonly sexo: FieldRef<"Clientes", 'String'>
    readonly edad: FieldRef<"Clientes", 'Int'>
    readonly fecha_nacimiento: FieldRef<"Clientes", 'DateTime'>
    readonly domicilio: FieldRef<"Clientes", 'String'>
    readonly telefono: FieldRef<"Clientes", 'String'>
    readonly curp: FieldRef<"Clientes", 'String'>
    readonly correo_electronico: FieldRef<"Clientes", 'String'>
    readonly tipo_sangre: FieldRef<"Clientes", 'String'>
    readonly ocupacion: FieldRef<"Clientes", 'String'>
    readonly escolaridad: FieldRef<"Clientes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Clientes findUnique
   */
  export type ClientesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes findUniqueOrThrow
   */
  export type ClientesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes findFirst
   */
  export type ClientesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }


  /**
   * Clientes findFirstOrThrow
   */
  export type ClientesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clientes.
     */
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }


  /**
   * Clientes findMany
   */
  export type ClientesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter, which Clientes to fetch.
     */
    where?: ClientesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clientes to fetch.
     */
    orderBy?: ClientesOrderByWithRelationInput | ClientesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clientes.
     */
    cursor?: ClientesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clientes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clientes.
     */
    skip?: number
    distinct?: ClientesScalarFieldEnum | ClientesScalarFieldEnum[]
  }


  /**
   * Clientes create
   */
  export type ClientesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The data needed to create a Clientes.
     */
    data: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
  }


  /**
   * Clientes createMany
   */
  export type ClientesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clientes.
     */
    data: ClientesCreateManyInput | ClientesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Clientes update
   */
  export type ClientesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The data needed to update a Clientes.
     */
    data: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
    /**
     * Choose, which Clientes to update.
     */
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes updateMany
   */
  export type ClientesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clientes.
     */
    data: XOR<ClientesUpdateManyMutationInput, ClientesUncheckedUpdateManyInput>
    /**
     * Filter which Clientes to update
     */
    where?: ClientesWhereInput
  }


  /**
   * Clientes upsert
   */
  export type ClientesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * The filter to search for the Clientes to update in case it exists.
     */
    where: ClientesWhereUniqueInput
    /**
     * In case the Clientes found by the `where` argument doesn't exist, create a new Clientes with this data.
     */
    create: XOR<ClientesCreateInput, ClientesUncheckedCreateInput>
    /**
     * In case the Clientes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientesUpdateInput, ClientesUncheckedUpdateInput>
  }


  /**
   * Clientes delete
   */
  export type ClientesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
    /**
     * Filter which Clientes to delete.
     */
    where: ClientesWhereUniqueInput
  }


  /**
   * Clientes deleteMany
   */
  export type ClientesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clientes to delete
     */
    where?: ClientesWhereInput
  }


  /**
   * Clientes.historial_clinico
   */
  export type Clientes$historial_clinicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    where?: HistorialClinicoWhereInput
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    cursor?: HistorialClinicoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialClinicoScalarFieldEnum | HistorialClinicoScalarFieldEnum[]
  }


  /**
   * Clientes.antecedentesNoPatologicos
   */
  export type Clientes$antecedentesNoPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    where?: AntecedentesNoPatologicosWhereInput
    orderBy?: AntecedentesNoPatologicosOrderByWithRelationInput | AntecedentesNoPatologicosOrderByWithRelationInput[]
    cursor?: AntecedentesNoPatologicosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AntecedentesNoPatologicosScalarFieldEnum | AntecedentesNoPatologicosScalarFieldEnum[]
  }


  /**
   * Clientes.antecedentesPatologicos
   */
  export type Clientes$antecedentesPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    where?: AntecedentesPatologicosWhereInput
    orderBy?: AntecedentesPatologicosOrderByWithRelationInput | AntecedentesPatologicosOrderByWithRelationInput[]
    cursor?: AntecedentesPatologicosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AntecedentesPatologicosScalarFieldEnum | AntecedentesPatologicosScalarFieldEnum[]
  }


  /**
   * Clientes.examenesClinicosIntraorales
   */
  export type Clientes$examenesClinicosIntraoralesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    where?: ExamenClinicoIntraoralWhereInput
    orderBy?: ExamenClinicoIntraoralOrderByWithRelationInput | ExamenClinicoIntraoralOrderByWithRelationInput[]
    cursor?: ExamenClinicoIntraoralWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamenClinicoIntraoralScalarFieldEnum | ExamenClinicoIntraoralScalarFieldEnum[]
  }


  /**
   * Clientes without action
   */
  export type ClientesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clientes
     */
    select?: ClientesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ClientesInclude<ExtArgs> | null
  }



  /**
   * Model Enfermedades
   */

  export type AggregateEnfermedades = {
    _count: EnfermedadesCountAggregateOutputType | null
    _avg: EnfermedadesAvgAggregateOutputType | null
    _sum: EnfermedadesSumAggregateOutputType | null
    _min: EnfermedadesMinAggregateOutputType | null
    _max: EnfermedadesMaxAggregateOutputType | null
  }

  export type EnfermedadesAvgAggregateOutputType = {
    id_enfermedad: number | null
  }

  export type EnfermedadesSumAggregateOutputType = {
    id_enfermedad: number | null
  }

  export type EnfermedadesMinAggregateOutputType = {
    id_enfermedad: number | null
    tipo: $Enums.TipoEnfermedadEnum | null
    otro: string | null
    causas: string | null
    sintomas: string | null
    tratamiento: string | null
  }

  export type EnfermedadesMaxAggregateOutputType = {
    id_enfermedad: number | null
    tipo: $Enums.TipoEnfermedadEnum | null
    otro: string | null
    causas: string | null
    sintomas: string | null
    tratamiento: string | null
  }

  export type EnfermedadesCountAggregateOutputType = {
    id_enfermedad: number
    tipo: number
    otro: number
    causas: number
    sintomas: number
    tratamiento: number
    _all: number
  }


  export type EnfermedadesAvgAggregateInputType = {
    id_enfermedad?: true
  }

  export type EnfermedadesSumAggregateInputType = {
    id_enfermedad?: true
  }

  export type EnfermedadesMinAggregateInputType = {
    id_enfermedad?: true
    tipo?: true
    otro?: true
    causas?: true
    sintomas?: true
    tratamiento?: true
  }

  export type EnfermedadesMaxAggregateInputType = {
    id_enfermedad?: true
    tipo?: true
    otro?: true
    causas?: true
    sintomas?: true
    tratamiento?: true
  }

  export type EnfermedadesCountAggregateInputType = {
    id_enfermedad?: true
    tipo?: true
    otro?: true
    causas?: true
    sintomas?: true
    tratamiento?: true
    _all?: true
  }

  export type EnfermedadesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enfermedades to aggregate.
     */
    where?: EnfermedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enfermedades to fetch.
     */
    orderBy?: EnfermedadesOrderByWithRelationInput | EnfermedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EnfermedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enfermedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enfermedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Enfermedades
    **/
    _count?: true | EnfermedadesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnfermedadesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnfermedadesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnfermedadesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnfermedadesMaxAggregateInputType
  }

  export type GetEnfermedadesAggregateType<T extends EnfermedadesAggregateArgs> = {
        [P in keyof T & keyof AggregateEnfermedades]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnfermedades[P]>
      : GetScalarType<T[P], AggregateEnfermedades[P]>
  }




  export type EnfermedadesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EnfermedadesWhereInput
    orderBy?: EnfermedadesOrderByWithAggregationInput | EnfermedadesOrderByWithAggregationInput[]
    by: EnfermedadesScalarFieldEnum[] | EnfermedadesScalarFieldEnum
    having?: EnfermedadesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnfermedadesCountAggregateInputType | true
    _avg?: EnfermedadesAvgAggregateInputType
    _sum?: EnfermedadesSumAggregateInputType
    _min?: EnfermedadesMinAggregateInputType
    _max?: EnfermedadesMaxAggregateInputType
  }

  export type EnfermedadesGroupByOutputType = {
    id_enfermedad: number
    tipo: $Enums.TipoEnfermedadEnum
    otro: string
    causas: string
    sintomas: string
    tratamiento: string
    _count: EnfermedadesCountAggregateOutputType | null
    _avg: EnfermedadesAvgAggregateOutputType | null
    _sum: EnfermedadesSumAggregateOutputType | null
    _min: EnfermedadesMinAggregateOutputType | null
    _max: EnfermedadesMaxAggregateOutputType | null
  }

  type GetEnfermedadesGroupByPayload<T extends EnfermedadesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnfermedadesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnfermedadesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnfermedadesGroupByOutputType[P]>
            : GetScalarType<T[P], EnfermedadesGroupByOutputType[P]>
        }
      >
    >


  export type EnfermedadesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_enfermedad?: boolean
    tipo?: boolean
    otro?: boolean
    causas?: boolean
    sintomas?: boolean
    tratamiento?: boolean
  }, ExtArgs["result"]["enfermedades"]>

  export type EnfermedadesSelectScalar = {
    id_enfermedad?: boolean
    tipo?: boolean
    otro?: boolean
    causas?: boolean
    sintomas?: boolean
    tratamiento?: boolean
  }


  export type $EnfermedadesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Enfermedades"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_enfermedad: number
      tipo: $Enums.TipoEnfermedadEnum
      otro: string
      causas: string
      sintomas: string
      tratamiento: string
    }, ExtArgs["result"]["enfermedades"]>
    composites: {}
  }


  type EnfermedadesGetPayload<S extends boolean | null | undefined | EnfermedadesDefaultArgs> = $Result.GetResult<Prisma.$EnfermedadesPayload, S>

  type EnfermedadesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EnfermedadesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EnfermedadesCountAggregateInputType | true
    }

  export interface EnfermedadesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Enfermedades'], meta: { name: 'Enfermedades' } }
    /**
     * Find zero or one Enfermedades that matches the filter.
     * @param {EnfermedadesFindUniqueArgs} args - Arguments to find a Enfermedades
     * @example
     * // Get one Enfermedades
     * const enfermedades = await prisma.enfermedades.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnfermedadesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesFindUniqueArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Enfermedades that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {EnfermedadesFindUniqueOrThrowArgs} args - Arguments to find a Enfermedades
     * @example
     * // Get one Enfermedades
     * const enfermedades = await prisma.enfermedades.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends EnfermedadesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Enfermedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesFindFirstArgs} args - Arguments to find a Enfermedades
     * @example
     * // Get one Enfermedades
     * const enfermedades = await prisma.enfermedades.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnfermedadesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesFindFirstArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Enfermedades that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesFindFirstOrThrowArgs} args - Arguments to find a Enfermedades
     * @example
     * // Get one Enfermedades
     * const enfermedades = await prisma.enfermedades.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends EnfermedadesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Enfermedades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enfermedades
     * const enfermedades = await prisma.enfermedades.findMany()
     * 
     * // Get first 10 Enfermedades
     * const enfermedades = await prisma.enfermedades.findMany({ take: 10 })
     * 
     * // Only select the `id_enfermedad`
     * const enfermedadesWithId_enfermedadOnly = await prisma.enfermedades.findMany({ select: { id_enfermedad: true } })
     * 
    **/
    findMany<T extends EnfermedadesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Enfermedades.
     * @param {EnfermedadesCreateArgs} args - Arguments to create a Enfermedades.
     * @example
     * // Create one Enfermedades
     * const Enfermedades = await prisma.enfermedades.create({
     *   data: {
     *     // ... data to create a Enfermedades
     *   }
     * })
     * 
    **/
    create<T extends EnfermedadesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesCreateArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Enfermedades.
     *     @param {EnfermedadesCreateManyArgs} args - Arguments to create many Enfermedades.
     *     @example
     *     // Create many Enfermedades
     *     const enfermedades = await prisma.enfermedades.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnfermedadesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Enfermedades.
     * @param {EnfermedadesDeleteArgs} args - Arguments to delete one Enfermedades.
     * @example
     * // Delete one Enfermedades
     * const Enfermedades = await prisma.enfermedades.delete({
     *   where: {
     *     // ... filter to delete one Enfermedades
     *   }
     * })
     * 
    **/
    delete<T extends EnfermedadesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesDeleteArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Enfermedades.
     * @param {EnfermedadesUpdateArgs} args - Arguments to update one Enfermedades.
     * @example
     * // Update one Enfermedades
     * const enfermedades = await prisma.enfermedades.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnfermedadesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesUpdateArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Enfermedades.
     * @param {EnfermedadesDeleteManyArgs} args - Arguments to filter Enfermedades to delete.
     * @example
     * // Delete a few Enfermedades
     * const { count } = await prisma.enfermedades.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnfermedadesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, EnfermedadesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enfermedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enfermedades
     * const enfermedades = await prisma.enfermedades.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnfermedadesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Enfermedades.
     * @param {EnfermedadesUpsertArgs} args - Arguments to update or create a Enfermedades.
     * @example
     * // Update or create a Enfermedades
     * const enfermedades = await prisma.enfermedades.upsert({
     *   create: {
     *     // ... data to create a Enfermedades
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enfermedades we want to update
     *   }
     * })
    **/
    upsert<T extends EnfermedadesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, EnfermedadesUpsertArgs<ExtArgs>>
    ): Prisma__EnfermedadesClient<$Result.GetResult<Prisma.$EnfermedadesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Enfermedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesCountArgs} args - Arguments to filter Enfermedades to count.
     * @example
     * // Count the number of Enfermedades
     * const count = await prisma.enfermedades.count({
     *   where: {
     *     // ... the filter for the Enfermedades we want to count
     *   }
     * })
    **/
    count<T extends EnfermedadesCountArgs>(
      args?: Subset<T, EnfermedadesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnfermedadesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enfermedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnfermedadesAggregateArgs>(args: Subset<T, EnfermedadesAggregateArgs>): Prisma.PrismaPromise<GetEnfermedadesAggregateType<T>>

    /**
     * Group by Enfermedades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnfermedadesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnfermedadesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnfermedadesGroupByArgs['orderBy'] }
        : { orderBy?: EnfermedadesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnfermedadesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnfermedadesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Enfermedades model
   */
  readonly fields: EnfermedadesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Enfermedades.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EnfermedadesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Enfermedades model
   */ 
  interface EnfermedadesFieldRefs {
    readonly id_enfermedad: FieldRef<"Enfermedades", 'Int'>
    readonly tipo: FieldRef<"Enfermedades", 'TipoEnfermedadEnum'>
    readonly otro: FieldRef<"Enfermedades", 'String'>
    readonly causas: FieldRef<"Enfermedades", 'String'>
    readonly sintomas: FieldRef<"Enfermedades", 'String'>
    readonly tratamiento: FieldRef<"Enfermedades", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Enfermedades findUnique
   */
  export type EnfermedadesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter, which Enfermedades to fetch.
     */
    where: EnfermedadesWhereUniqueInput
  }


  /**
   * Enfermedades findUniqueOrThrow
   */
  export type EnfermedadesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter, which Enfermedades to fetch.
     */
    where: EnfermedadesWhereUniqueInput
  }


  /**
   * Enfermedades findFirst
   */
  export type EnfermedadesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter, which Enfermedades to fetch.
     */
    where?: EnfermedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enfermedades to fetch.
     */
    orderBy?: EnfermedadesOrderByWithRelationInput | EnfermedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enfermedades.
     */
    cursor?: EnfermedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enfermedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enfermedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enfermedades.
     */
    distinct?: EnfermedadesScalarFieldEnum | EnfermedadesScalarFieldEnum[]
  }


  /**
   * Enfermedades findFirstOrThrow
   */
  export type EnfermedadesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter, which Enfermedades to fetch.
     */
    where?: EnfermedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enfermedades to fetch.
     */
    orderBy?: EnfermedadesOrderByWithRelationInput | EnfermedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Enfermedades.
     */
    cursor?: EnfermedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enfermedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enfermedades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Enfermedades.
     */
    distinct?: EnfermedadesScalarFieldEnum | EnfermedadesScalarFieldEnum[]
  }


  /**
   * Enfermedades findMany
   */
  export type EnfermedadesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter, which Enfermedades to fetch.
     */
    where?: EnfermedadesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Enfermedades to fetch.
     */
    orderBy?: EnfermedadesOrderByWithRelationInput | EnfermedadesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Enfermedades.
     */
    cursor?: EnfermedadesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Enfermedades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Enfermedades.
     */
    skip?: number
    distinct?: EnfermedadesScalarFieldEnum | EnfermedadesScalarFieldEnum[]
  }


  /**
   * Enfermedades create
   */
  export type EnfermedadesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * The data needed to create a Enfermedades.
     */
    data: XOR<EnfermedadesCreateInput, EnfermedadesUncheckedCreateInput>
  }


  /**
   * Enfermedades createMany
   */
  export type EnfermedadesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Enfermedades.
     */
    data: EnfermedadesCreateManyInput | EnfermedadesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Enfermedades update
   */
  export type EnfermedadesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * The data needed to update a Enfermedades.
     */
    data: XOR<EnfermedadesUpdateInput, EnfermedadesUncheckedUpdateInput>
    /**
     * Choose, which Enfermedades to update.
     */
    where: EnfermedadesWhereUniqueInput
  }


  /**
   * Enfermedades updateMany
   */
  export type EnfermedadesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Enfermedades.
     */
    data: XOR<EnfermedadesUpdateManyMutationInput, EnfermedadesUncheckedUpdateManyInput>
    /**
     * Filter which Enfermedades to update
     */
    where?: EnfermedadesWhereInput
  }


  /**
   * Enfermedades upsert
   */
  export type EnfermedadesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * The filter to search for the Enfermedades to update in case it exists.
     */
    where: EnfermedadesWhereUniqueInput
    /**
     * In case the Enfermedades found by the `where` argument doesn't exist, create a new Enfermedades with this data.
     */
    create: XOR<EnfermedadesCreateInput, EnfermedadesUncheckedCreateInput>
    /**
     * In case the Enfermedades was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EnfermedadesUpdateInput, EnfermedadesUncheckedUpdateInput>
  }


  /**
   * Enfermedades delete
   */
  export type EnfermedadesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
    /**
     * Filter which Enfermedades to delete.
     */
    where: EnfermedadesWhereUniqueInput
  }


  /**
   * Enfermedades deleteMany
   */
  export type EnfermedadesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Enfermedades to delete
     */
    where?: EnfermedadesWhereInput
  }


  /**
   * Enfermedades without action
   */
  export type EnfermedadesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Enfermedades
     */
    select?: EnfermedadesSelect<ExtArgs> | null
  }



  /**
   * Model AntecedentesNoPatologicos
   */

  export type AggregateAntecedentesNoPatologicos = {
    _count: AntecedentesNoPatologicosCountAggregateOutputType | null
    _avg: AntecedentesNoPatologicosAvgAggregateOutputType | null
    _sum: AntecedentesNoPatologicosSumAggregateOutputType | null
    _min: AntecedentesNoPatologicosMinAggregateOutputType | null
    _max: AntecedentesNoPatologicosMaxAggregateOutputType | null
  }

  export type AntecedentesNoPatologicosAvgAggregateOutputType = {
    id_paciente: number | null
  }

  export type AntecedentesNoPatologicosSumAggregateOutputType = {
    id_paciente: number | null
  }

  export type AntecedentesNoPatologicosMinAggregateOutputType = {
    id_paciente: number | null
    tabaquismo: $Enums.SiNoEnum | null
    toxicomanias: $Enums.SiNoEnum | null
    alcoholismo: $Enums.SiNoEnum | null
    sedentarismo: $Enums.SiNoEnum | null
    cirugias: string | null
    ejercicio: string | null
  }

  export type AntecedentesNoPatologicosMaxAggregateOutputType = {
    id_paciente: number | null
    tabaquismo: $Enums.SiNoEnum | null
    toxicomanias: $Enums.SiNoEnum | null
    alcoholismo: $Enums.SiNoEnum | null
    sedentarismo: $Enums.SiNoEnum | null
    cirugias: string | null
    ejercicio: string | null
  }

  export type AntecedentesNoPatologicosCountAggregateOutputType = {
    id_paciente: number
    tabaquismo: number
    toxicomanias: number
    alcoholismo: number
    sedentarismo: number
    cirugias: number
    ejercicio: number
    _all: number
  }


  export type AntecedentesNoPatologicosAvgAggregateInputType = {
    id_paciente?: true
  }

  export type AntecedentesNoPatologicosSumAggregateInputType = {
    id_paciente?: true
  }

  export type AntecedentesNoPatologicosMinAggregateInputType = {
    id_paciente?: true
    tabaquismo?: true
    toxicomanias?: true
    alcoholismo?: true
    sedentarismo?: true
    cirugias?: true
    ejercicio?: true
  }

  export type AntecedentesNoPatologicosMaxAggregateInputType = {
    id_paciente?: true
    tabaquismo?: true
    toxicomanias?: true
    alcoholismo?: true
    sedentarismo?: true
    cirugias?: true
    ejercicio?: true
  }

  export type AntecedentesNoPatologicosCountAggregateInputType = {
    id_paciente?: true
    tabaquismo?: true
    toxicomanias?: true
    alcoholismo?: true
    sedentarismo?: true
    cirugias?: true
    ejercicio?: true
    _all?: true
  }

  export type AntecedentesNoPatologicosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AntecedentesNoPatologicos to aggregate.
     */
    where?: AntecedentesNoPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesNoPatologicos to fetch.
     */
    orderBy?: AntecedentesNoPatologicosOrderByWithRelationInput | AntecedentesNoPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AntecedentesNoPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesNoPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesNoPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AntecedentesNoPatologicos
    **/
    _count?: true | AntecedentesNoPatologicosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AntecedentesNoPatologicosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AntecedentesNoPatologicosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AntecedentesNoPatologicosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AntecedentesNoPatologicosMaxAggregateInputType
  }

  export type GetAntecedentesNoPatologicosAggregateType<T extends AntecedentesNoPatologicosAggregateArgs> = {
        [P in keyof T & keyof AggregateAntecedentesNoPatologicos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAntecedentesNoPatologicos[P]>
      : GetScalarType<T[P], AggregateAntecedentesNoPatologicos[P]>
  }




  export type AntecedentesNoPatologicosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentesNoPatologicosWhereInput
    orderBy?: AntecedentesNoPatologicosOrderByWithAggregationInput | AntecedentesNoPatologicosOrderByWithAggregationInput[]
    by: AntecedentesNoPatologicosScalarFieldEnum[] | AntecedentesNoPatologicosScalarFieldEnum
    having?: AntecedentesNoPatologicosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AntecedentesNoPatologicosCountAggregateInputType | true
    _avg?: AntecedentesNoPatologicosAvgAggregateInputType
    _sum?: AntecedentesNoPatologicosSumAggregateInputType
    _min?: AntecedentesNoPatologicosMinAggregateInputType
    _max?: AntecedentesNoPatologicosMaxAggregateInputType
  }

  export type AntecedentesNoPatologicosGroupByOutputType = {
    id_paciente: number
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias: string | null
    ejercicio: string | null
    _count: AntecedentesNoPatologicosCountAggregateOutputType | null
    _avg: AntecedentesNoPatologicosAvgAggregateOutputType | null
    _sum: AntecedentesNoPatologicosSumAggregateOutputType | null
    _min: AntecedentesNoPatologicosMinAggregateOutputType | null
    _max: AntecedentesNoPatologicosMaxAggregateOutputType | null
  }

  type GetAntecedentesNoPatologicosGroupByPayload<T extends AntecedentesNoPatologicosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AntecedentesNoPatologicosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AntecedentesNoPatologicosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AntecedentesNoPatologicosGroupByOutputType[P]>
            : GetScalarType<T[P], AntecedentesNoPatologicosGroupByOutputType[P]>
        }
      >
    >


  export type AntecedentesNoPatologicosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    tabaquismo?: boolean
    toxicomanias?: boolean
    alcoholismo?: boolean
    sedentarismo?: boolean
    cirugias?: boolean
    ejercicio?: boolean
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["antecedentesNoPatologicos"]>

  export type AntecedentesNoPatologicosSelectScalar = {
    id_paciente?: boolean
    tabaquismo?: boolean
    toxicomanias?: boolean
    alcoholismo?: boolean
    sedentarismo?: boolean
    cirugias?: boolean
    ejercicio?: boolean
  }

  export type AntecedentesNoPatologicosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }


  export type $AntecedentesNoPatologicosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AntecedentesNoPatologicos"
    objects: {
      paciente: Prisma.$ClientesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paciente: number
      tabaquismo: $Enums.SiNoEnum
      toxicomanias: $Enums.SiNoEnum
      alcoholismo: $Enums.SiNoEnum
      sedentarismo: $Enums.SiNoEnum
      cirugias: string | null
      ejercicio: string | null
    }, ExtArgs["result"]["antecedentesNoPatologicos"]>
    composites: {}
  }


  type AntecedentesNoPatologicosGetPayload<S extends boolean | null | undefined | AntecedentesNoPatologicosDefaultArgs> = $Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload, S>

  type AntecedentesNoPatologicosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AntecedentesNoPatologicosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AntecedentesNoPatologicosCountAggregateInputType | true
    }

  export interface AntecedentesNoPatologicosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AntecedentesNoPatologicos'], meta: { name: 'AntecedentesNoPatologicos' } }
    /**
     * Find zero or one AntecedentesNoPatologicos that matches the filter.
     * @param {AntecedentesNoPatologicosFindUniqueArgs} args - Arguments to find a AntecedentesNoPatologicos
     * @example
     * // Get one AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AntecedentesNoPatologicosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosFindUniqueArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AntecedentesNoPatologicos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AntecedentesNoPatologicosFindUniqueOrThrowArgs} args - Arguments to find a AntecedentesNoPatologicos
     * @example
     * // Get one AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AntecedentesNoPatologicosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AntecedentesNoPatologicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosFindFirstArgs} args - Arguments to find a AntecedentesNoPatologicos
     * @example
     * // Get one AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AntecedentesNoPatologicosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosFindFirstArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AntecedentesNoPatologicos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosFindFirstOrThrowArgs} args - Arguments to find a AntecedentesNoPatologicos
     * @example
     * // Get one AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AntecedentesNoPatologicosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AntecedentesNoPatologicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findMany()
     * 
     * // Get first 10 AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.findMany({ take: 10 })
     * 
     * // Only select the `id_paciente`
     * const antecedentesNoPatologicosWithId_pacienteOnly = await prisma.antecedentesNoPatologicos.findMany({ select: { id_paciente: true } })
     * 
    **/
    findMany<T extends AntecedentesNoPatologicosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AntecedentesNoPatologicos.
     * @param {AntecedentesNoPatologicosCreateArgs} args - Arguments to create a AntecedentesNoPatologicos.
     * @example
     * // Create one AntecedentesNoPatologicos
     * const AntecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.create({
     *   data: {
     *     // ... data to create a AntecedentesNoPatologicos
     *   }
     * })
     * 
    **/
    create<T extends AntecedentesNoPatologicosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosCreateArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AntecedentesNoPatologicos.
     *     @param {AntecedentesNoPatologicosCreateManyArgs} args - Arguments to create many AntecedentesNoPatologicos.
     *     @example
     *     // Create many AntecedentesNoPatologicos
     *     const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AntecedentesNoPatologicosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AntecedentesNoPatologicos.
     * @param {AntecedentesNoPatologicosDeleteArgs} args - Arguments to delete one AntecedentesNoPatologicos.
     * @example
     * // Delete one AntecedentesNoPatologicos
     * const AntecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.delete({
     *   where: {
     *     // ... filter to delete one AntecedentesNoPatologicos
     *   }
     * })
     * 
    **/
    delete<T extends AntecedentesNoPatologicosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosDeleteArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AntecedentesNoPatologicos.
     * @param {AntecedentesNoPatologicosUpdateArgs} args - Arguments to update one AntecedentesNoPatologicos.
     * @example
     * // Update one AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AntecedentesNoPatologicosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosUpdateArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AntecedentesNoPatologicos.
     * @param {AntecedentesNoPatologicosDeleteManyArgs} args - Arguments to filter AntecedentesNoPatologicos to delete.
     * @example
     * // Delete a few AntecedentesNoPatologicos
     * const { count } = await prisma.antecedentesNoPatologicos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AntecedentesNoPatologicosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesNoPatologicosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AntecedentesNoPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AntecedentesNoPatologicosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AntecedentesNoPatologicos.
     * @param {AntecedentesNoPatologicosUpsertArgs} args - Arguments to update or create a AntecedentesNoPatologicos.
     * @example
     * // Update or create a AntecedentesNoPatologicos
     * const antecedentesNoPatologicos = await prisma.antecedentesNoPatologicos.upsert({
     *   create: {
     *     // ... data to create a AntecedentesNoPatologicos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AntecedentesNoPatologicos we want to update
     *   }
     * })
    **/
    upsert<T extends AntecedentesNoPatologicosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesNoPatologicosUpsertArgs<ExtArgs>>
    ): Prisma__AntecedentesNoPatologicosClient<$Result.GetResult<Prisma.$AntecedentesNoPatologicosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AntecedentesNoPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosCountArgs} args - Arguments to filter AntecedentesNoPatologicos to count.
     * @example
     * // Count the number of AntecedentesNoPatologicos
     * const count = await prisma.antecedentesNoPatologicos.count({
     *   where: {
     *     // ... the filter for the AntecedentesNoPatologicos we want to count
     *   }
     * })
    **/
    count<T extends AntecedentesNoPatologicosCountArgs>(
      args?: Subset<T, AntecedentesNoPatologicosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AntecedentesNoPatologicosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AntecedentesNoPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AntecedentesNoPatologicosAggregateArgs>(args: Subset<T, AntecedentesNoPatologicosAggregateArgs>): Prisma.PrismaPromise<GetAntecedentesNoPatologicosAggregateType<T>>

    /**
     * Group by AntecedentesNoPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesNoPatologicosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AntecedentesNoPatologicosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AntecedentesNoPatologicosGroupByArgs['orderBy'] }
        : { orderBy?: AntecedentesNoPatologicosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AntecedentesNoPatologicosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAntecedentesNoPatologicosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AntecedentesNoPatologicos model
   */
  readonly fields: AntecedentesNoPatologicosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AntecedentesNoPatologicos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AntecedentesNoPatologicosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    paciente<T extends ClientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientesDefaultArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AntecedentesNoPatologicos model
   */ 
  interface AntecedentesNoPatologicosFieldRefs {
    readonly id_paciente: FieldRef<"AntecedentesNoPatologicos", 'Int'>
    readonly tabaquismo: FieldRef<"AntecedentesNoPatologicos", 'SiNoEnum'>
    readonly toxicomanias: FieldRef<"AntecedentesNoPatologicos", 'SiNoEnum'>
    readonly alcoholismo: FieldRef<"AntecedentesNoPatologicos", 'SiNoEnum'>
    readonly sedentarismo: FieldRef<"AntecedentesNoPatologicos", 'SiNoEnum'>
    readonly cirugias: FieldRef<"AntecedentesNoPatologicos", 'String'>
    readonly ejercicio: FieldRef<"AntecedentesNoPatologicos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AntecedentesNoPatologicos findUnique
   */
  export type AntecedentesNoPatologicosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesNoPatologicos to fetch.
     */
    where: AntecedentesNoPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesNoPatologicos findUniqueOrThrow
   */
  export type AntecedentesNoPatologicosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesNoPatologicos to fetch.
     */
    where: AntecedentesNoPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesNoPatologicos findFirst
   */
  export type AntecedentesNoPatologicosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesNoPatologicos to fetch.
     */
    where?: AntecedentesNoPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesNoPatologicos to fetch.
     */
    orderBy?: AntecedentesNoPatologicosOrderByWithRelationInput | AntecedentesNoPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AntecedentesNoPatologicos.
     */
    cursor?: AntecedentesNoPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesNoPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesNoPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AntecedentesNoPatologicos.
     */
    distinct?: AntecedentesNoPatologicosScalarFieldEnum | AntecedentesNoPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesNoPatologicos findFirstOrThrow
   */
  export type AntecedentesNoPatologicosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesNoPatologicos to fetch.
     */
    where?: AntecedentesNoPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesNoPatologicos to fetch.
     */
    orderBy?: AntecedentesNoPatologicosOrderByWithRelationInput | AntecedentesNoPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AntecedentesNoPatologicos.
     */
    cursor?: AntecedentesNoPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesNoPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesNoPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AntecedentesNoPatologicos.
     */
    distinct?: AntecedentesNoPatologicosScalarFieldEnum | AntecedentesNoPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesNoPatologicos findMany
   */
  export type AntecedentesNoPatologicosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesNoPatologicos to fetch.
     */
    where?: AntecedentesNoPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesNoPatologicos to fetch.
     */
    orderBy?: AntecedentesNoPatologicosOrderByWithRelationInput | AntecedentesNoPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AntecedentesNoPatologicos.
     */
    cursor?: AntecedentesNoPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesNoPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesNoPatologicos.
     */
    skip?: number
    distinct?: AntecedentesNoPatologicosScalarFieldEnum | AntecedentesNoPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesNoPatologicos create
   */
  export type AntecedentesNoPatologicosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * The data needed to create a AntecedentesNoPatologicos.
     */
    data: XOR<AntecedentesNoPatologicosCreateInput, AntecedentesNoPatologicosUncheckedCreateInput>
  }


  /**
   * AntecedentesNoPatologicos createMany
   */
  export type AntecedentesNoPatologicosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AntecedentesNoPatologicos.
     */
    data: AntecedentesNoPatologicosCreateManyInput | AntecedentesNoPatologicosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AntecedentesNoPatologicos update
   */
  export type AntecedentesNoPatologicosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * The data needed to update a AntecedentesNoPatologicos.
     */
    data: XOR<AntecedentesNoPatologicosUpdateInput, AntecedentesNoPatologicosUncheckedUpdateInput>
    /**
     * Choose, which AntecedentesNoPatologicos to update.
     */
    where: AntecedentesNoPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesNoPatologicos updateMany
   */
  export type AntecedentesNoPatologicosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AntecedentesNoPatologicos.
     */
    data: XOR<AntecedentesNoPatologicosUpdateManyMutationInput, AntecedentesNoPatologicosUncheckedUpdateManyInput>
    /**
     * Filter which AntecedentesNoPatologicos to update
     */
    where?: AntecedentesNoPatologicosWhereInput
  }


  /**
   * AntecedentesNoPatologicos upsert
   */
  export type AntecedentesNoPatologicosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * The filter to search for the AntecedentesNoPatologicos to update in case it exists.
     */
    where: AntecedentesNoPatologicosWhereUniqueInput
    /**
     * In case the AntecedentesNoPatologicos found by the `where` argument doesn't exist, create a new AntecedentesNoPatologicos with this data.
     */
    create: XOR<AntecedentesNoPatologicosCreateInput, AntecedentesNoPatologicosUncheckedCreateInput>
    /**
     * In case the AntecedentesNoPatologicos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AntecedentesNoPatologicosUpdateInput, AntecedentesNoPatologicosUncheckedUpdateInput>
  }


  /**
   * AntecedentesNoPatologicos delete
   */
  export type AntecedentesNoPatologicosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
    /**
     * Filter which AntecedentesNoPatologicos to delete.
     */
    where: AntecedentesNoPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesNoPatologicos deleteMany
   */
  export type AntecedentesNoPatologicosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AntecedentesNoPatologicos to delete
     */
    where?: AntecedentesNoPatologicosWhereInput
  }


  /**
   * AntecedentesNoPatologicos without action
   */
  export type AntecedentesNoPatologicosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesNoPatologicos
     */
    select?: AntecedentesNoPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesNoPatologicosInclude<ExtArgs> | null
  }



  /**
   * Model AntecedentesPatologicos
   */

  export type AggregateAntecedentesPatologicos = {
    _count: AntecedentesPatologicosCountAggregateOutputType | null
    _avg: AntecedentesPatologicosAvgAggregateOutputType | null
    _sum: AntecedentesPatologicosSumAggregateOutputType | null
    _min: AntecedentesPatologicosMinAggregateOutputType | null
    _max: AntecedentesPatologicosMaxAggregateOutputType | null
  }

  export type AntecedentesPatologicosAvgAggregateOutputType = {
    id: number | null
    paciente_id: number | null
  }

  export type AntecedentesPatologicosSumAggregateOutputType = {
    id: number | null
    paciente_id: number | null
  }

  export type AntecedentesPatologicosMinAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    enfermedad: string | null
    fecha_diagnostico: Date | null
    tipo_enfermedad: $Enums.TipoEnfermedadEnum | null
    cronica: $Enums.SiNoEnum | null
    tratamiento: string | null
    observaciones: string | null
  }

  export type AntecedentesPatologicosMaxAggregateOutputType = {
    id: number | null
    paciente_id: number | null
    enfermedad: string | null
    fecha_diagnostico: Date | null
    tipo_enfermedad: $Enums.TipoEnfermedadEnum | null
    cronica: $Enums.SiNoEnum | null
    tratamiento: string | null
    observaciones: string | null
  }

  export type AntecedentesPatologicosCountAggregateOutputType = {
    id: number
    paciente_id: number
    enfermedad: number
    fecha_diagnostico: number
    tipo_enfermedad: number
    cronica: number
    tratamiento: number
    observaciones: number
    _all: number
  }


  export type AntecedentesPatologicosAvgAggregateInputType = {
    id?: true
    paciente_id?: true
  }

  export type AntecedentesPatologicosSumAggregateInputType = {
    id?: true
    paciente_id?: true
  }

  export type AntecedentesPatologicosMinAggregateInputType = {
    id?: true
    paciente_id?: true
    enfermedad?: true
    fecha_diagnostico?: true
    tipo_enfermedad?: true
    cronica?: true
    tratamiento?: true
    observaciones?: true
  }

  export type AntecedentesPatologicosMaxAggregateInputType = {
    id?: true
    paciente_id?: true
    enfermedad?: true
    fecha_diagnostico?: true
    tipo_enfermedad?: true
    cronica?: true
    tratamiento?: true
    observaciones?: true
  }

  export type AntecedentesPatologicosCountAggregateInputType = {
    id?: true
    paciente_id?: true
    enfermedad?: true
    fecha_diagnostico?: true
    tipo_enfermedad?: true
    cronica?: true
    tratamiento?: true
    observaciones?: true
    _all?: true
  }

  export type AntecedentesPatologicosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AntecedentesPatologicos to aggregate.
     */
    where?: AntecedentesPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesPatologicos to fetch.
     */
    orderBy?: AntecedentesPatologicosOrderByWithRelationInput | AntecedentesPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AntecedentesPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AntecedentesPatologicos
    **/
    _count?: true | AntecedentesPatologicosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AntecedentesPatologicosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AntecedentesPatologicosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AntecedentesPatologicosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AntecedentesPatologicosMaxAggregateInputType
  }

  export type GetAntecedentesPatologicosAggregateType<T extends AntecedentesPatologicosAggregateArgs> = {
        [P in keyof T & keyof AggregateAntecedentesPatologicos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAntecedentesPatologicos[P]>
      : GetScalarType<T[P], AggregateAntecedentesPatologicos[P]>
  }




  export type AntecedentesPatologicosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AntecedentesPatologicosWhereInput
    orderBy?: AntecedentesPatologicosOrderByWithAggregationInput | AntecedentesPatologicosOrderByWithAggregationInput[]
    by: AntecedentesPatologicosScalarFieldEnum[] | AntecedentesPatologicosScalarFieldEnum
    having?: AntecedentesPatologicosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AntecedentesPatologicosCountAggregateInputType | true
    _avg?: AntecedentesPatologicosAvgAggregateInputType
    _sum?: AntecedentesPatologicosSumAggregateInputType
    _min?: AntecedentesPatologicosMinAggregateInputType
    _max?: AntecedentesPatologicosMaxAggregateInputType
  }

  export type AntecedentesPatologicosGroupByOutputType = {
    id: number
    paciente_id: number
    enfermedad: string
    fecha_diagnostico: Date
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento: string | null
    observaciones: string | null
    _count: AntecedentesPatologicosCountAggregateOutputType | null
    _avg: AntecedentesPatologicosAvgAggregateOutputType | null
    _sum: AntecedentesPatologicosSumAggregateOutputType | null
    _min: AntecedentesPatologicosMinAggregateOutputType | null
    _max: AntecedentesPatologicosMaxAggregateOutputType | null
  }

  type GetAntecedentesPatologicosGroupByPayload<T extends AntecedentesPatologicosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AntecedentesPatologicosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AntecedentesPatologicosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AntecedentesPatologicosGroupByOutputType[P]>
            : GetScalarType<T[P], AntecedentesPatologicosGroupByOutputType[P]>
        }
      >
    >


  export type AntecedentesPatologicosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paciente_id?: boolean
    enfermedad?: boolean
    fecha_diagnostico?: boolean
    tipo_enfermedad?: boolean
    cronica?: boolean
    tratamiento?: boolean
    observaciones?: boolean
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["antecedentesPatologicos"]>

  export type AntecedentesPatologicosSelectScalar = {
    id?: boolean
    paciente_id?: boolean
    enfermedad?: boolean
    fecha_diagnostico?: boolean
    tipo_enfermedad?: boolean
    cronica?: boolean
    tratamiento?: boolean
    observaciones?: boolean
  }

  export type AntecedentesPatologicosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }


  export type $AntecedentesPatologicosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AntecedentesPatologicos"
    objects: {
      paciente: Prisma.$ClientesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      paciente_id: number
      enfermedad: string
      fecha_diagnostico: Date
      tipo_enfermedad: $Enums.TipoEnfermedadEnum
      cronica: $Enums.SiNoEnum
      tratamiento: string | null
      observaciones: string | null
    }, ExtArgs["result"]["antecedentesPatologicos"]>
    composites: {}
  }


  type AntecedentesPatologicosGetPayload<S extends boolean | null | undefined | AntecedentesPatologicosDefaultArgs> = $Result.GetResult<Prisma.$AntecedentesPatologicosPayload, S>

  type AntecedentesPatologicosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AntecedentesPatologicosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AntecedentesPatologicosCountAggregateInputType | true
    }

  export interface AntecedentesPatologicosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AntecedentesPatologicos'], meta: { name: 'AntecedentesPatologicos' } }
    /**
     * Find zero or one AntecedentesPatologicos that matches the filter.
     * @param {AntecedentesPatologicosFindUniqueArgs} args - Arguments to find a AntecedentesPatologicos
     * @example
     * // Get one AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AntecedentesPatologicosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosFindUniqueArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one AntecedentesPatologicos that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AntecedentesPatologicosFindUniqueOrThrowArgs} args - Arguments to find a AntecedentesPatologicos
     * @example
     * // Get one AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AntecedentesPatologicosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first AntecedentesPatologicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosFindFirstArgs} args - Arguments to find a AntecedentesPatologicos
     * @example
     * // Get one AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AntecedentesPatologicosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosFindFirstArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first AntecedentesPatologicos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosFindFirstOrThrowArgs} args - Arguments to find a AntecedentesPatologicos
     * @example
     * // Get one AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AntecedentesPatologicosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more AntecedentesPatologicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findMany()
     * 
     * // Get first 10 AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const antecedentesPatologicosWithIdOnly = await prisma.antecedentesPatologicos.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AntecedentesPatologicosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a AntecedentesPatologicos.
     * @param {AntecedentesPatologicosCreateArgs} args - Arguments to create a AntecedentesPatologicos.
     * @example
     * // Create one AntecedentesPatologicos
     * const AntecedentesPatologicos = await prisma.antecedentesPatologicos.create({
     *   data: {
     *     // ... data to create a AntecedentesPatologicos
     *   }
     * })
     * 
    **/
    create<T extends AntecedentesPatologicosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosCreateArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many AntecedentesPatologicos.
     *     @param {AntecedentesPatologicosCreateManyArgs} args - Arguments to create many AntecedentesPatologicos.
     *     @example
     *     // Create many AntecedentesPatologicos
     *     const antecedentesPatologicos = await prisma.antecedentesPatologicos.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AntecedentesPatologicosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AntecedentesPatologicos.
     * @param {AntecedentesPatologicosDeleteArgs} args - Arguments to delete one AntecedentesPatologicos.
     * @example
     * // Delete one AntecedentesPatologicos
     * const AntecedentesPatologicos = await prisma.antecedentesPatologicos.delete({
     *   where: {
     *     // ... filter to delete one AntecedentesPatologicos
     *   }
     * })
     * 
    **/
    delete<T extends AntecedentesPatologicosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosDeleteArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one AntecedentesPatologicos.
     * @param {AntecedentesPatologicosUpdateArgs} args - Arguments to update one AntecedentesPatologicos.
     * @example
     * // Update one AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AntecedentesPatologicosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosUpdateArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more AntecedentesPatologicos.
     * @param {AntecedentesPatologicosDeleteManyArgs} args - Arguments to filter AntecedentesPatologicos to delete.
     * @example
     * // Delete a few AntecedentesPatologicos
     * const { count } = await prisma.antecedentesPatologicos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AntecedentesPatologicosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AntecedentesPatologicosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AntecedentesPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AntecedentesPatologicosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AntecedentesPatologicos.
     * @param {AntecedentesPatologicosUpsertArgs} args - Arguments to update or create a AntecedentesPatologicos.
     * @example
     * // Update or create a AntecedentesPatologicos
     * const antecedentesPatologicos = await prisma.antecedentesPatologicos.upsert({
     *   create: {
     *     // ... data to create a AntecedentesPatologicos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AntecedentesPatologicos we want to update
     *   }
     * })
    **/
    upsert<T extends AntecedentesPatologicosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AntecedentesPatologicosUpsertArgs<ExtArgs>>
    ): Prisma__AntecedentesPatologicosClient<$Result.GetResult<Prisma.$AntecedentesPatologicosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of AntecedentesPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosCountArgs} args - Arguments to filter AntecedentesPatologicos to count.
     * @example
     * // Count the number of AntecedentesPatologicos
     * const count = await prisma.antecedentesPatologicos.count({
     *   where: {
     *     // ... the filter for the AntecedentesPatologicos we want to count
     *   }
     * })
    **/
    count<T extends AntecedentesPatologicosCountArgs>(
      args?: Subset<T, AntecedentesPatologicosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AntecedentesPatologicosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AntecedentesPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AntecedentesPatologicosAggregateArgs>(args: Subset<T, AntecedentesPatologicosAggregateArgs>): Prisma.PrismaPromise<GetAntecedentesPatologicosAggregateType<T>>

    /**
     * Group by AntecedentesPatologicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AntecedentesPatologicosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AntecedentesPatologicosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AntecedentesPatologicosGroupByArgs['orderBy'] }
        : { orderBy?: AntecedentesPatologicosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AntecedentesPatologicosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAntecedentesPatologicosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AntecedentesPatologicos model
   */
  readonly fields: AntecedentesPatologicosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AntecedentesPatologicos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AntecedentesPatologicosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    paciente<T extends ClientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientesDefaultArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the AntecedentesPatologicos model
   */ 
  interface AntecedentesPatologicosFieldRefs {
    readonly id: FieldRef<"AntecedentesPatologicos", 'Int'>
    readonly paciente_id: FieldRef<"AntecedentesPatologicos", 'Int'>
    readonly enfermedad: FieldRef<"AntecedentesPatologicos", 'String'>
    readonly fecha_diagnostico: FieldRef<"AntecedentesPatologicos", 'DateTime'>
    readonly tipo_enfermedad: FieldRef<"AntecedentesPatologicos", 'TipoEnfermedadEnum'>
    readonly cronica: FieldRef<"AntecedentesPatologicos", 'SiNoEnum'>
    readonly tratamiento: FieldRef<"AntecedentesPatologicos", 'String'>
    readonly observaciones: FieldRef<"AntecedentesPatologicos", 'String'>
  }
    

  // Custom InputTypes

  /**
   * AntecedentesPatologicos findUnique
   */
  export type AntecedentesPatologicosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesPatologicos to fetch.
     */
    where: AntecedentesPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesPatologicos findUniqueOrThrow
   */
  export type AntecedentesPatologicosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesPatologicos to fetch.
     */
    where: AntecedentesPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesPatologicos findFirst
   */
  export type AntecedentesPatologicosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesPatologicos to fetch.
     */
    where?: AntecedentesPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesPatologicos to fetch.
     */
    orderBy?: AntecedentesPatologicosOrderByWithRelationInput | AntecedentesPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AntecedentesPatologicos.
     */
    cursor?: AntecedentesPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AntecedentesPatologicos.
     */
    distinct?: AntecedentesPatologicosScalarFieldEnum | AntecedentesPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesPatologicos findFirstOrThrow
   */
  export type AntecedentesPatologicosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesPatologicos to fetch.
     */
    where?: AntecedentesPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesPatologicos to fetch.
     */
    orderBy?: AntecedentesPatologicosOrderByWithRelationInput | AntecedentesPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AntecedentesPatologicos.
     */
    cursor?: AntecedentesPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesPatologicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AntecedentesPatologicos.
     */
    distinct?: AntecedentesPatologicosScalarFieldEnum | AntecedentesPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesPatologicos findMany
   */
  export type AntecedentesPatologicosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter, which AntecedentesPatologicos to fetch.
     */
    where?: AntecedentesPatologicosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AntecedentesPatologicos to fetch.
     */
    orderBy?: AntecedentesPatologicosOrderByWithRelationInput | AntecedentesPatologicosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AntecedentesPatologicos.
     */
    cursor?: AntecedentesPatologicosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AntecedentesPatologicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AntecedentesPatologicos.
     */
    skip?: number
    distinct?: AntecedentesPatologicosScalarFieldEnum | AntecedentesPatologicosScalarFieldEnum[]
  }


  /**
   * AntecedentesPatologicos create
   */
  export type AntecedentesPatologicosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * The data needed to create a AntecedentesPatologicos.
     */
    data: XOR<AntecedentesPatologicosCreateInput, AntecedentesPatologicosUncheckedCreateInput>
  }


  /**
   * AntecedentesPatologicos createMany
   */
  export type AntecedentesPatologicosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AntecedentesPatologicos.
     */
    data: AntecedentesPatologicosCreateManyInput | AntecedentesPatologicosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * AntecedentesPatologicos update
   */
  export type AntecedentesPatologicosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * The data needed to update a AntecedentesPatologicos.
     */
    data: XOR<AntecedentesPatologicosUpdateInput, AntecedentesPatologicosUncheckedUpdateInput>
    /**
     * Choose, which AntecedentesPatologicos to update.
     */
    where: AntecedentesPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesPatologicos updateMany
   */
  export type AntecedentesPatologicosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AntecedentesPatologicos.
     */
    data: XOR<AntecedentesPatologicosUpdateManyMutationInput, AntecedentesPatologicosUncheckedUpdateManyInput>
    /**
     * Filter which AntecedentesPatologicos to update
     */
    where?: AntecedentesPatologicosWhereInput
  }


  /**
   * AntecedentesPatologicos upsert
   */
  export type AntecedentesPatologicosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * The filter to search for the AntecedentesPatologicos to update in case it exists.
     */
    where: AntecedentesPatologicosWhereUniqueInput
    /**
     * In case the AntecedentesPatologicos found by the `where` argument doesn't exist, create a new AntecedentesPatologicos with this data.
     */
    create: XOR<AntecedentesPatologicosCreateInput, AntecedentesPatologicosUncheckedCreateInput>
    /**
     * In case the AntecedentesPatologicos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AntecedentesPatologicosUpdateInput, AntecedentesPatologicosUncheckedUpdateInput>
  }


  /**
   * AntecedentesPatologicos delete
   */
  export type AntecedentesPatologicosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
    /**
     * Filter which AntecedentesPatologicos to delete.
     */
    where: AntecedentesPatologicosWhereUniqueInput
  }


  /**
   * AntecedentesPatologicos deleteMany
   */
  export type AntecedentesPatologicosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AntecedentesPatologicos to delete
     */
    where?: AntecedentesPatologicosWhereInput
  }


  /**
   * AntecedentesPatologicos without action
   */
  export type AntecedentesPatologicosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AntecedentesPatologicos
     */
    select?: AntecedentesPatologicosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AntecedentesPatologicosInclude<ExtArgs> | null
  }



  /**
   * Model ExamenClinicoIntraoral
   */

  export type AggregateExamenClinicoIntraoral = {
    _count: ExamenClinicoIntraoralCountAggregateOutputType | null
    _avg: ExamenClinicoIntraoralAvgAggregateOutputType | null
    _sum: ExamenClinicoIntraoralSumAggregateOutputType | null
    _min: ExamenClinicoIntraoralMinAggregateOutputType | null
    _max: ExamenClinicoIntraoralMaxAggregateOutputType | null
  }

  export type ExamenClinicoIntraoralAvgAggregateOutputType = {
    id_paciente: number | null
  }

  export type ExamenClinicoIntraoralSumAggregateOutputType = {
    id_paciente: number | null
  }

  export type ExamenClinicoIntraoralMinAggregateOutputType = {
    id_paciente: number | null
    fecha_examen: Date | null
    encia: string | null
    lengua: string | null
    paladar_duro: string | null
    paladar_blando: string | null
    faringe: string | null
    piso_de_la_boca: string | null
    reborde_residual: string | null
    tipo_oclusion: string | null
    observaciones: string | null
  }

  export type ExamenClinicoIntraoralMaxAggregateOutputType = {
    id_paciente: number | null
    fecha_examen: Date | null
    encia: string | null
    lengua: string | null
    paladar_duro: string | null
    paladar_blando: string | null
    faringe: string | null
    piso_de_la_boca: string | null
    reborde_residual: string | null
    tipo_oclusion: string | null
    observaciones: string | null
  }

  export type ExamenClinicoIntraoralCountAggregateOutputType = {
    id_paciente: number
    fecha_examen: number
    encia: number
    lengua: number
    paladar_duro: number
    paladar_blando: number
    faringe: number
    piso_de_la_boca: number
    reborde_residual: number
    tipo_oclusion: number
    observaciones: number
    _all: number
  }


  export type ExamenClinicoIntraoralAvgAggregateInputType = {
    id_paciente?: true
  }

  export type ExamenClinicoIntraoralSumAggregateInputType = {
    id_paciente?: true
  }

  export type ExamenClinicoIntraoralMinAggregateInputType = {
    id_paciente?: true
    fecha_examen?: true
    encia?: true
    lengua?: true
    paladar_duro?: true
    paladar_blando?: true
    faringe?: true
    piso_de_la_boca?: true
    reborde_residual?: true
    tipo_oclusion?: true
    observaciones?: true
  }

  export type ExamenClinicoIntraoralMaxAggregateInputType = {
    id_paciente?: true
    fecha_examen?: true
    encia?: true
    lengua?: true
    paladar_duro?: true
    paladar_blando?: true
    faringe?: true
    piso_de_la_boca?: true
    reborde_residual?: true
    tipo_oclusion?: true
    observaciones?: true
  }

  export type ExamenClinicoIntraoralCountAggregateInputType = {
    id_paciente?: true
    fecha_examen?: true
    encia?: true
    lengua?: true
    paladar_duro?: true
    paladar_blando?: true
    faringe?: true
    piso_de_la_boca?: true
    reborde_residual?: true
    tipo_oclusion?: true
    observaciones?: true
    _all?: true
  }

  export type ExamenClinicoIntraoralAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamenClinicoIntraoral to aggregate.
     */
    where?: ExamenClinicoIntraoralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamenClinicoIntraorals to fetch.
     */
    orderBy?: ExamenClinicoIntraoralOrderByWithRelationInput | ExamenClinicoIntraoralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamenClinicoIntraoralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamenClinicoIntraorals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamenClinicoIntraorals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExamenClinicoIntraorals
    **/
    _count?: true | ExamenClinicoIntraoralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamenClinicoIntraoralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamenClinicoIntraoralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamenClinicoIntraoralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamenClinicoIntraoralMaxAggregateInputType
  }

  export type GetExamenClinicoIntraoralAggregateType<T extends ExamenClinicoIntraoralAggregateArgs> = {
        [P in keyof T & keyof AggregateExamenClinicoIntraoral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExamenClinicoIntraoral[P]>
      : GetScalarType<T[P], AggregateExamenClinicoIntraoral[P]>
  }




  export type ExamenClinicoIntraoralGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamenClinicoIntraoralWhereInput
    orderBy?: ExamenClinicoIntraoralOrderByWithAggregationInput | ExamenClinicoIntraoralOrderByWithAggregationInput[]
    by: ExamenClinicoIntraoralScalarFieldEnum[] | ExamenClinicoIntraoralScalarFieldEnum
    having?: ExamenClinicoIntraoralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamenClinicoIntraoralCountAggregateInputType | true
    _avg?: ExamenClinicoIntraoralAvgAggregateInputType
    _sum?: ExamenClinicoIntraoralSumAggregateInputType
    _min?: ExamenClinicoIntraoralMinAggregateInputType
    _max?: ExamenClinicoIntraoralMaxAggregateInputType
  }

  export type ExamenClinicoIntraoralGroupByOutputType = {
    id_paciente: number
    fecha_examen: Date
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones: string | null
    _count: ExamenClinicoIntraoralCountAggregateOutputType | null
    _avg: ExamenClinicoIntraoralAvgAggregateOutputType | null
    _sum: ExamenClinicoIntraoralSumAggregateOutputType | null
    _min: ExamenClinicoIntraoralMinAggregateOutputType | null
    _max: ExamenClinicoIntraoralMaxAggregateOutputType | null
  }

  type GetExamenClinicoIntraoralGroupByPayload<T extends ExamenClinicoIntraoralGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamenClinicoIntraoralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamenClinicoIntraoralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamenClinicoIntraoralGroupByOutputType[P]>
            : GetScalarType<T[P], ExamenClinicoIntraoralGroupByOutputType[P]>
        }
      >
    >


  export type ExamenClinicoIntraoralSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_paciente?: boolean
    fecha_examen?: boolean
    encia?: boolean
    lengua?: boolean
    paladar_duro?: boolean
    paladar_blando?: boolean
    faringe?: boolean
    piso_de_la_boca?: boolean
    reborde_residual?: boolean
    tipo_oclusion?: boolean
    observaciones?: boolean
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["examenClinicoIntraoral"]>

  export type ExamenClinicoIntraoralSelectScalar = {
    id_paciente?: boolean
    fecha_examen?: boolean
    encia?: boolean
    lengua?: boolean
    paladar_duro?: boolean
    paladar_blando?: boolean
    faringe?: boolean
    piso_de_la_boca?: boolean
    reborde_residual?: boolean
    tipo_oclusion?: boolean
    observaciones?: boolean
  }

  export type ExamenClinicoIntraoralInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    paciente?: boolean | ClientesDefaultArgs<ExtArgs>
  }


  export type $ExamenClinicoIntraoralPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExamenClinicoIntraoral"
    objects: {
      paciente: Prisma.$ClientesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_paciente: number
      fecha_examen: Date
      encia: string
      lengua: string
      paladar_duro: string
      paladar_blando: string
      faringe: string
      piso_de_la_boca: string
      reborde_residual: string
      tipo_oclusion: string
      observaciones: string | null
    }, ExtArgs["result"]["examenClinicoIntraoral"]>
    composites: {}
  }


  type ExamenClinicoIntraoralGetPayload<S extends boolean | null | undefined | ExamenClinicoIntraoralDefaultArgs> = $Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload, S>

  type ExamenClinicoIntraoralCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamenClinicoIntraoralFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamenClinicoIntraoralCountAggregateInputType | true
    }

  export interface ExamenClinicoIntraoralDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExamenClinicoIntraoral'], meta: { name: 'ExamenClinicoIntraoral' } }
    /**
     * Find zero or one ExamenClinicoIntraoral that matches the filter.
     * @param {ExamenClinicoIntraoralFindUniqueArgs} args - Arguments to find a ExamenClinicoIntraoral
     * @example
     * // Get one ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExamenClinicoIntraoralFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralFindUniqueArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ExamenClinicoIntraoral that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExamenClinicoIntraoralFindUniqueOrThrowArgs} args - Arguments to find a ExamenClinicoIntraoral
     * @example
     * // Get one ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExamenClinicoIntraoralFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ExamenClinicoIntraoral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralFindFirstArgs} args - Arguments to find a ExamenClinicoIntraoral
     * @example
     * // Get one ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExamenClinicoIntraoralFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralFindFirstArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ExamenClinicoIntraoral that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralFindFirstOrThrowArgs} args - Arguments to find a ExamenClinicoIntraoral
     * @example
     * // Get one ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExamenClinicoIntraoralFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ExamenClinicoIntraorals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExamenClinicoIntraorals
     * const examenClinicoIntraorals = await prisma.examenClinicoIntraoral.findMany()
     * 
     * // Get first 10 ExamenClinicoIntraorals
     * const examenClinicoIntraorals = await prisma.examenClinicoIntraoral.findMany({ take: 10 })
     * 
     * // Only select the `id_paciente`
     * const examenClinicoIntraoralWithId_pacienteOnly = await prisma.examenClinicoIntraoral.findMany({ select: { id_paciente: true } })
     * 
    **/
    findMany<T extends ExamenClinicoIntraoralFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ExamenClinicoIntraoral.
     * @param {ExamenClinicoIntraoralCreateArgs} args - Arguments to create a ExamenClinicoIntraoral.
     * @example
     * // Create one ExamenClinicoIntraoral
     * const ExamenClinicoIntraoral = await prisma.examenClinicoIntraoral.create({
     *   data: {
     *     // ... data to create a ExamenClinicoIntraoral
     *   }
     * })
     * 
    **/
    create<T extends ExamenClinicoIntraoralCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralCreateArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ExamenClinicoIntraorals.
     *     @param {ExamenClinicoIntraoralCreateManyArgs} args - Arguments to create many ExamenClinicoIntraorals.
     *     @example
     *     // Create many ExamenClinicoIntraorals
     *     const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExamenClinicoIntraoralCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExamenClinicoIntraoral.
     * @param {ExamenClinicoIntraoralDeleteArgs} args - Arguments to delete one ExamenClinicoIntraoral.
     * @example
     * // Delete one ExamenClinicoIntraoral
     * const ExamenClinicoIntraoral = await prisma.examenClinicoIntraoral.delete({
     *   where: {
     *     // ... filter to delete one ExamenClinicoIntraoral
     *   }
     * })
     * 
    **/
    delete<T extends ExamenClinicoIntraoralDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralDeleteArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ExamenClinicoIntraoral.
     * @param {ExamenClinicoIntraoralUpdateArgs} args - Arguments to update one ExamenClinicoIntraoral.
     * @example
     * // Update one ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExamenClinicoIntraoralUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralUpdateArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ExamenClinicoIntraorals.
     * @param {ExamenClinicoIntraoralDeleteManyArgs} args - Arguments to filter ExamenClinicoIntraorals to delete.
     * @example
     * // Delete a few ExamenClinicoIntraorals
     * const { count } = await prisma.examenClinicoIntraoral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExamenClinicoIntraoralDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ExamenClinicoIntraoralDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExamenClinicoIntraorals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExamenClinicoIntraorals
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExamenClinicoIntraoralUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExamenClinicoIntraoral.
     * @param {ExamenClinicoIntraoralUpsertArgs} args - Arguments to update or create a ExamenClinicoIntraoral.
     * @example
     * // Update or create a ExamenClinicoIntraoral
     * const examenClinicoIntraoral = await prisma.examenClinicoIntraoral.upsert({
     *   create: {
     *     // ... data to create a ExamenClinicoIntraoral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExamenClinicoIntraoral we want to update
     *   }
     * })
    **/
    upsert<T extends ExamenClinicoIntraoralUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ExamenClinicoIntraoralUpsertArgs<ExtArgs>>
    ): Prisma__ExamenClinicoIntraoralClient<$Result.GetResult<Prisma.$ExamenClinicoIntraoralPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ExamenClinicoIntraorals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralCountArgs} args - Arguments to filter ExamenClinicoIntraorals to count.
     * @example
     * // Count the number of ExamenClinicoIntraorals
     * const count = await prisma.examenClinicoIntraoral.count({
     *   where: {
     *     // ... the filter for the ExamenClinicoIntraorals we want to count
     *   }
     * })
    **/
    count<T extends ExamenClinicoIntraoralCountArgs>(
      args?: Subset<T, ExamenClinicoIntraoralCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamenClinicoIntraoralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExamenClinicoIntraoral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamenClinicoIntraoralAggregateArgs>(args: Subset<T, ExamenClinicoIntraoralAggregateArgs>): Prisma.PrismaPromise<GetExamenClinicoIntraoralAggregateType<T>>

    /**
     * Group by ExamenClinicoIntraoral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamenClinicoIntraoralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamenClinicoIntraoralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamenClinicoIntraoralGroupByArgs['orderBy'] }
        : { orderBy?: ExamenClinicoIntraoralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamenClinicoIntraoralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamenClinicoIntraoralGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExamenClinicoIntraoral model
   */
  readonly fields: ExamenClinicoIntraoralFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExamenClinicoIntraoral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamenClinicoIntraoralClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    paciente<T extends ClientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientesDefaultArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ExamenClinicoIntraoral model
   */ 
  interface ExamenClinicoIntraoralFieldRefs {
    readonly id_paciente: FieldRef<"ExamenClinicoIntraoral", 'Int'>
    readonly fecha_examen: FieldRef<"ExamenClinicoIntraoral", 'DateTime'>
    readonly encia: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly lengua: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly paladar_duro: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly paladar_blando: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly faringe: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly piso_de_la_boca: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly reborde_residual: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly tipo_oclusion: FieldRef<"ExamenClinicoIntraoral", 'String'>
    readonly observaciones: FieldRef<"ExamenClinicoIntraoral", 'String'>
  }
    

  // Custom InputTypes

  /**
   * ExamenClinicoIntraoral findUnique
   */
  export type ExamenClinicoIntraoralFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter, which ExamenClinicoIntraoral to fetch.
     */
    where: ExamenClinicoIntraoralWhereUniqueInput
  }


  /**
   * ExamenClinicoIntraoral findUniqueOrThrow
   */
  export type ExamenClinicoIntraoralFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter, which ExamenClinicoIntraoral to fetch.
     */
    where: ExamenClinicoIntraoralWhereUniqueInput
  }


  /**
   * ExamenClinicoIntraoral findFirst
   */
  export type ExamenClinicoIntraoralFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter, which ExamenClinicoIntraoral to fetch.
     */
    where?: ExamenClinicoIntraoralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamenClinicoIntraorals to fetch.
     */
    orderBy?: ExamenClinicoIntraoralOrderByWithRelationInput | ExamenClinicoIntraoralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamenClinicoIntraorals.
     */
    cursor?: ExamenClinicoIntraoralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamenClinicoIntraorals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamenClinicoIntraorals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamenClinicoIntraorals.
     */
    distinct?: ExamenClinicoIntraoralScalarFieldEnum | ExamenClinicoIntraoralScalarFieldEnum[]
  }


  /**
   * ExamenClinicoIntraoral findFirstOrThrow
   */
  export type ExamenClinicoIntraoralFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter, which ExamenClinicoIntraoral to fetch.
     */
    where?: ExamenClinicoIntraoralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamenClinicoIntraorals to fetch.
     */
    orderBy?: ExamenClinicoIntraoralOrderByWithRelationInput | ExamenClinicoIntraoralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExamenClinicoIntraorals.
     */
    cursor?: ExamenClinicoIntraoralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamenClinicoIntraorals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamenClinicoIntraorals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExamenClinicoIntraorals.
     */
    distinct?: ExamenClinicoIntraoralScalarFieldEnum | ExamenClinicoIntraoralScalarFieldEnum[]
  }


  /**
   * ExamenClinicoIntraoral findMany
   */
  export type ExamenClinicoIntraoralFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter, which ExamenClinicoIntraorals to fetch.
     */
    where?: ExamenClinicoIntraoralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExamenClinicoIntraorals to fetch.
     */
    orderBy?: ExamenClinicoIntraoralOrderByWithRelationInput | ExamenClinicoIntraoralOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExamenClinicoIntraorals.
     */
    cursor?: ExamenClinicoIntraoralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExamenClinicoIntraorals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExamenClinicoIntraorals.
     */
    skip?: number
    distinct?: ExamenClinicoIntraoralScalarFieldEnum | ExamenClinicoIntraoralScalarFieldEnum[]
  }


  /**
   * ExamenClinicoIntraoral create
   */
  export type ExamenClinicoIntraoralCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * The data needed to create a ExamenClinicoIntraoral.
     */
    data: XOR<ExamenClinicoIntraoralCreateInput, ExamenClinicoIntraoralUncheckedCreateInput>
  }


  /**
   * ExamenClinicoIntraoral createMany
   */
  export type ExamenClinicoIntraoralCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExamenClinicoIntraorals.
     */
    data: ExamenClinicoIntraoralCreateManyInput | ExamenClinicoIntraoralCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * ExamenClinicoIntraoral update
   */
  export type ExamenClinicoIntraoralUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * The data needed to update a ExamenClinicoIntraoral.
     */
    data: XOR<ExamenClinicoIntraoralUpdateInput, ExamenClinicoIntraoralUncheckedUpdateInput>
    /**
     * Choose, which ExamenClinicoIntraoral to update.
     */
    where: ExamenClinicoIntraoralWhereUniqueInput
  }


  /**
   * ExamenClinicoIntraoral updateMany
   */
  export type ExamenClinicoIntraoralUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExamenClinicoIntraorals.
     */
    data: XOR<ExamenClinicoIntraoralUpdateManyMutationInput, ExamenClinicoIntraoralUncheckedUpdateManyInput>
    /**
     * Filter which ExamenClinicoIntraorals to update
     */
    where?: ExamenClinicoIntraoralWhereInput
  }


  /**
   * ExamenClinicoIntraoral upsert
   */
  export type ExamenClinicoIntraoralUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * The filter to search for the ExamenClinicoIntraoral to update in case it exists.
     */
    where: ExamenClinicoIntraoralWhereUniqueInput
    /**
     * In case the ExamenClinicoIntraoral found by the `where` argument doesn't exist, create a new ExamenClinicoIntraoral with this data.
     */
    create: XOR<ExamenClinicoIntraoralCreateInput, ExamenClinicoIntraoralUncheckedCreateInput>
    /**
     * In case the ExamenClinicoIntraoral was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamenClinicoIntraoralUpdateInput, ExamenClinicoIntraoralUncheckedUpdateInput>
  }


  /**
   * ExamenClinicoIntraoral delete
   */
  export type ExamenClinicoIntraoralDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
    /**
     * Filter which ExamenClinicoIntraoral to delete.
     */
    where: ExamenClinicoIntraoralWhereUniqueInput
  }


  /**
   * ExamenClinicoIntraoral deleteMany
   */
  export type ExamenClinicoIntraoralDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExamenClinicoIntraorals to delete
     */
    where?: ExamenClinicoIntraoralWhereInput
  }


  /**
   * ExamenClinicoIntraoral without action
   */
  export type ExamenClinicoIntraoralDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExamenClinicoIntraoral
     */
    select?: ExamenClinicoIntraoralSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExamenClinicoIntraoralInclude<ExtArgs> | null
  }



  /**
   * Model HistorialClinico
   */

  export type AggregateHistorialClinico = {
    _count: HistorialClinicoCountAggregateOutputType | null
    _avg: HistorialClinicoAvgAggregateOutputType | null
    _sum: HistorialClinicoSumAggregateOutputType | null
    _min: HistorialClinicoMinAggregateOutputType | null
    _max: HistorialClinicoMaxAggregateOutputType | null
  }

  export type HistorialClinicoAvgAggregateOutputType = {
    id: number | null
    cliente_id: number | null
    dentista_id: number | null
  }

  export type HistorialClinicoSumAggregateOutputType = {
    id: number | null
    cliente_id: number | null
    dentista_id: number | null
  }

  export type HistorialClinicoMinAggregateOutputType = {
    id: number | null
    cliente_id: number | null
    dentista_id: number | null
    fecha_consulta: Date | null
  }

  export type HistorialClinicoMaxAggregateOutputType = {
    id: number | null
    cliente_id: number | null
    dentista_id: number | null
    fecha_consulta: Date | null
  }

  export type HistorialClinicoCountAggregateOutputType = {
    id: number
    cliente_id: number
    dentista_id: number
    fecha_consulta: number
    datos_clinicos: number
    _all: number
  }


  export type HistorialClinicoAvgAggregateInputType = {
    id?: true
    cliente_id?: true
    dentista_id?: true
  }

  export type HistorialClinicoSumAggregateInputType = {
    id?: true
    cliente_id?: true
    dentista_id?: true
  }

  export type HistorialClinicoMinAggregateInputType = {
    id?: true
    cliente_id?: true
    dentista_id?: true
    fecha_consulta?: true
  }

  export type HistorialClinicoMaxAggregateInputType = {
    id?: true
    cliente_id?: true
    dentista_id?: true
    fecha_consulta?: true
  }

  export type HistorialClinicoCountAggregateInputType = {
    id?: true
    cliente_id?: true
    dentista_id?: true
    fecha_consulta?: true
    datos_clinicos?: true
    _all?: true
  }

  export type HistorialClinicoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialClinico to aggregate.
     */
    where?: HistorialClinicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialClinicos to fetch.
     */
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialClinicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialClinicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialClinicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorialClinicos
    **/
    _count?: true | HistorialClinicoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialClinicoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialClinicoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialClinicoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialClinicoMaxAggregateInputType
  }

  export type GetHistorialClinicoAggregateType<T extends HistorialClinicoAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorialClinico]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorialClinico[P]>
      : GetScalarType<T[P], AggregateHistorialClinico[P]>
  }




  export type HistorialClinicoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialClinicoWhereInput
    orderBy?: HistorialClinicoOrderByWithAggregationInput | HistorialClinicoOrderByWithAggregationInput[]
    by: HistorialClinicoScalarFieldEnum[] | HistorialClinicoScalarFieldEnum
    having?: HistorialClinicoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialClinicoCountAggregateInputType | true
    _avg?: HistorialClinicoAvgAggregateInputType
    _sum?: HistorialClinicoSumAggregateInputType
    _min?: HistorialClinicoMinAggregateInputType
    _max?: HistorialClinicoMaxAggregateInputType
  }

  export type HistorialClinicoGroupByOutputType = {
    id: number
    cliente_id: number
    dentista_id: number
    fecha_consulta: Date
    datos_clinicos: JsonValue
    _count: HistorialClinicoCountAggregateOutputType | null
    _avg: HistorialClinicoAvgAggregateOutputType | null
    _sum: HistorialClinicoSumAggregateOutputType | null
    _min: HistorialClinicoMinAggregateOutputType | null
    _max: HistorialClinicoMaxAggregateOutputType | null
  }

  type GetHistorialClinicoGroupByPayload<T extends HistorialClinicoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialClinicoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialClinicoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialClinicoGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialClinicoGroupByOutputType[P]>
        }
      >
    >


  export type HistorialClinicoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cliente_id?: boolean
    dentista_id?: boolean
    fecha_consulta?: boolean
    datos_clinicos?: boolean
    cliente?: boolean | ClientesDefaultArgs<ExtArgs>
    dentista?: boolean | DoctorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historialClinico"]>

  export type HistorialClinicoSelectScalar = {
    id?: boolean
    cliente_id?: boolean
    dentista_id?: boolean
    fecha_consulta?: boolean
    datos_clinicos?: boolean
  }

  export type HistorialClinicoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cliente?: boolean | ClientesDefaultArgs<ExtArgs>
    dentista?: boolean | DoctorDefaultArgs<ExtArgs>
  }


  export type $HistorialClinicoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorialClinico"
    objects: {
      cliente: Prisma.$ClientesPayload<ExtArgs>
      dentista: Prisma.$DoctorPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      cliente_id: number
      dentista_id: number
      fecha_consulta: Date
      datos_clinicos: Prisma.JsonValue
    }, ExtArgs["result"]["historialClinico"]>
    composites: {}
  }


  type HistorialClinicoGetPayload<S extends boolean | null | undefined | HistorialClinicoDefaultArgs> = $Result.GetResult<Prisma.$HistorialClinicoPayload, S>

  type HistorialClinicoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialClinicoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialClinicoCountAggregateInputType | true
    }

  export interface HistorialClinicoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorialClinico'], meta: { name: 'HistorialClinico' } }
    /**
     * Find zero or one HistorialClinico that matches the filter.
     * @param {HistorialClinicoFindUniqueArgs} args - Arguments to find a HistorialClinico
     * @example
     * // Get one HistorialClinico
     * const historialClinico = await prisma.historialClinico.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends HistorialClinicoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoFindUniqueArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one HistorialClinico that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {HistorialClinicoFindUniqueOrThrowArgs} args - Arguments to find a HistorialClinico
     * @example
     * // Get one HistorialClinico
     * const historialClinico = await prisma.historialClinico.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends HistorialClinicoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first HistorialClinico that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoFindFirstArgs} args - Arguments to find a HistorialClinico
     * @example
     * // Get one HistorialClinico
     * const historialClinico = await prisma.historialClinico.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends HistorialClinicoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoFindFirstArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first HistorialClinico that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoFindFirstOrThrowArgs} args - Arguments to find a HistorialClinico
     * @example
     * // Get one HistorialClinico
     * const historialClinico = await prisma.historialClinico.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends HistorialClinicoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more HistorialClinicos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorialClinicos
     * const historialClinicos = await prisma.historialClinico.findMany()
     * 
     * // Get first 10 HistorialClinicos
     * const historialClinicos = await prisma.historialClinico.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historialClinicoWithIdOnly = await prisma.historialClinico.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends HistorialClinicoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a HistorialClinico.
     * @param {HistorialClinicoCreateArgs} args - Arguments to create a HistorialClinico.
     * @example
     * // Create one HistorialClinico
     * const HistorialClinico = await prisma.historialClinico.create({
     *   data: {
     *     // ... data to create a HistorialClinico
     *   }
     * })
     * 
    **/
    create<T extends HistorialClinicoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoCreateArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many HistorialClinicos.
     *     @param {HistorialClinicoCreateManyArgs} args - Arguments to create many HistorialClinicos.
     *     @example
     *     // Create many HistorialClinicos
     *     const historialClinico = await prisma.historialClinico.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends HistorialClinicoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a HistorialClinico.
     * @param {HistorialClinicoDeleteArgs} args - Arguments to delete one HistorialClinico.
     * @example
     * // Delete one HistorialClinico
     * const HistorialClinico = await prisma.historialClinico.delete({
     *   where: {
     *     // ... filter to delete one HistorialClinico
     *   }
     * })
     * 
    **/
    delete<T extends HistorialClinicoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoDeleteArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one HistorialClinico.
     * @param {HistorialClinicoUpdateArgs} args - Arguments to update one HistorialClinico.
     * @example
     * // Update one HistorialClinico
     * const historialClinico = await prisma.historialClinico.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends HistorialClinicoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoUpdateArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more HistorialClinicos.
     * @param {HistorialClinicoDeleteManyArgs} args - Arguments to filter HistorialClinicos to delete.
     * @example
     * // Delete a few HistorialClinicos
     * const { count } = await prisma.historialClinico.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends HistorialClinicoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, HistorialClinicoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorialClinicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorialClinicos
     * const historialClinico = await prisma.historialClinico.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends HistorialClinicoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistorialClinico.
     * @param {HistorialClinicoUpsertArgs} args - Arguments to update or create a HistorialClinico.
     * @example
     * // Update or create a HistorialClinico
     * const historialClinico = await prisma.historialClinico.upsert({
     *   create: {
     *     // ... data to create a HistorialClinico
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorialClinico we want to update
     *   }
     * })
    **/
    upsert<T extends HistorialClinicoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, HistorialClinicoUpsertArgs<ExtArgs>>
    ): Prisma__HistorialClinicoClient<$Result.GetResult<Prisma.$HistorialClinicoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of HistorialClinicos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoCountArgs} args - Arguments to filter HistorialClinicos to count.
     * @example
     * // Count the number of HistorialClinicos
     * const count = await prisma.historialClinico.count({
     *   where: {
     *     // ... the filter for the HistorialClinicos we want to count
     *   }
     * })
    **/
    count<T extends HistorialClinicoCountArgs>(
      args?: Subset<T, HistorialClinicoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialClinicoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorialClinico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialClinicoAggregateArgs>(args: Subset<T, HistorialClinicoAggregateArgs>): Prisma.PrismaPromise<GetHistorialClinicoAggregateType<T>>

    /**
     * Group by HistorialClinico.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialClinicoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialClinicoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialClinicoGroupByArgs['orderBy'] }
        : { orderBy?: HistorialClinicoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialClinicoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialClinicoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorialClinico model
   */
  readonly fields: HistorialClinicoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorialClinico.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialClinicoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cliente<T extends ClientesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientesDefaultArgs<ExtArgs>>): Prisma__ClientesClient<$Result.GetResult<Prisma.$ClientesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    dentista<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the HistorialClinico model
   */ 
  interface HistorialClinicoFieldRefs {
    readonly id: FieldRef<"HistorialClinico", 'Int'>
    readonly cliente_id: FieldRef<"HistorialClinico", 'Int'>
    readonly dentista_id: FieldRef<"HistorialClinico", 'Int'>
    readonly fecha_consulta: FieldRef<"HistorialClinico", 'DateTime'>
    readonly datos_clinicos: FieldRef<"HistorialClinico", 'Json'>
  }
    

  // Custom InputTypes

  /**
   * HistorialClinico findUnique
   */
  export type HistorialClinicoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter, which HistorialClinico to fetch.
     */
    where: HistorialClinicoWhereUniqueInput
  }


  /**
   * HistorialClinico findUniqueOrThrow
   */
  export type HistorialClinicoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter, which HistorialClinico to fetch.
     */
    where: HistorialClinicoWhereUniqueInput
  }


  /**
   * HistorialClinico findFirst
   */
  export type HistorialClinicoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter, which HistorialClinico to fetch.
     */
    where?: HistorialClinicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialClinicos to fetch.
     */
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialClinicos.
     */
    cursor?: HistorialClinicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialClinicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialClinicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialClinicos.
     */
    distinct?: HistorialClinicoScalarFieldEnum | HistorialClinicoScalarFieldEnum[]
  }


  /**
   * HistorialClinico findFirstOrThrow
   */
  export type HistorialClinicoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter, which HistorialClinico to fetch.
     */
    where?: HistorialClinicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialClinicos to fetch.
     */
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialClinicos.
     */
    cursor?: HistorialClinicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialClinicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialClinicos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialClinicos.
     */
    distinct?: HistorialClinicoScalarFieldEnum | HistorialClinicoScalarFieldEnum[]
  }


  /**
   * HistorialClinico findMany
   */
  export type HistorialClinicoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter, which HistorialClinicos to fetch.
     */
    where?: HistorialClinicoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialClinicos to fetch.
     */
    orderBy?: HistorialClinicoOrderByWithRelationInput | HistorialClinicoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorialClinicos.
     */
    cursor?: HistorialClinicoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialClinicos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialClinicos.
     */
    skip?: number
    distinct?: HistorialClinicoScalarFieldEnum | HistorialClinicoScalarFieldEnum[]
  }


  /**
   * HistorialClinico create
   */
  export type HistorialClinicoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorialClinico.
     */
    data: XOR<HistorialClinicoCreateInput, HistorialClinicoUncheckedCreateInput>
  }


  /**
   * HistorialClinico createMany
   */
  export type HistorialClinicoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorialClinicos.
     */
    data: HistorialClinicoCreateManyInput | HistorialClinicoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * HistorialClinico update
   */
  export type HistorialClinicoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorialClinico.
     */
    data: XOR<HistorialClinicoUpdateInput, HistorialClinicoUncheckedUpdateInput>
    /**
     * Choose, which HistorialClinico to update.
     */
    where: HistorialClinicoWhereUniqueInput
  }


  /**
   * HistorialClinico updateMany
   */
  export type HistorialClinicoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorialClinicos.
     */
    data: XOR<HistorialClinicoUpdateManyMutationInput, HistorialClinicoUncheckedUpdateManyInput>
    /**
     * Filter which HistorialClinicos to update
     */
    where?: HistorialClinicoWhereInput
  }


  /**
   * HistorialClinico upsert
   */
  export type HistorialClinicoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorialClinico to update in case it exists.
     */
    where: HistorialClinicoWhereUniqueInput
    /**
     * In case the HistorialClinico found by the `where` argument doesn't exist, create a new HistorialClinico with this data.
     */
    create: XOR<HistorialClinicoCreateInput, HistorialClinicoUncheckedCreateInput>
    /**
     * In case the HistorialClinico was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialClinicoUpdateInput, HistorialClinicoUncheckedUpdateInput>
  }


  /**
   * HistorialClinico delete
   */
  export type HistorialClinicoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
    /**
     * Filter which HistorialClinico to delete.
     */
    where: HistorialClinicoWhereUniqueInput
  }


  /**
   * HistorialClinico deleteMany
   */
  export type HistorialClinicoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialClinicos to delete
     */
    where?: HistorialClinicoWhereInput
  }


  /**
   * HistorialClinico without action
   */
  export type HistorialClinicoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialClinico
     */
    select?: HistorialClinicoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: HistorialClinicoInclude<ExtArgs> | null
  }



  /**
   * Model Permiso
   */

  export type AggregatePermiso = {
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  export type PermisoAvgAggregateOutputType = {
    id: number | null
  }

  export type PermisoSumAggregateOutputType = {
    id: number | null
  }

  export type PermisoMinAggregateOutputType = {
    id: number | null
    permiso: string | null
    descripcion: string | null
  }

  export type PermisoMaxAggregateOutputType = {
    id: number | null
    permiso: string | null
    descripcion: string | null
  }

  export type PermisoCountAggregateOutputType = {
    id: number
    permiso: number
    descripcion: number
    _all: number
  }


  export type PermisoAvgAggregateInputType = {
    id?: true
  }

  export type PermisoSumAggregateInputType = {
    id?: true
  }

  export type PermisoMinAggregateInputType = {
    id?: true
    permiso?: true
    descripcion?: true
  }

  export type PermisoMaxAggregateInputType = {
    id?: true
    permiso?: true
    descripcion?: true
  }

  export type PermisoCountAggregateInputType = {
    id?: true
    permiso?: true
    descripcion?: true
    _all?: true
  }

  export type PermisoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permiso to aggregate.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permisos
    **/
    _count?: true | PermisoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermisoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermisoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermisoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermisoMaxAggregateInputType
  }

  export type GetPermisoAggregateType<T extends PermisoAggregateArgs> = {
        [P in keyof T & keyof AggregatePermiso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermiso[P]>
      : GetScalarType<T[P], AggregatePermiso[P]>
  }




  export type PermisoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermisoWhereInput
    orderBy?: PermisoOrderByWithAggregationInput | PermisoOrderByWithAggregationInput[]
    by: PermisoScalarFieldEnum[] | PermisoScalarFieldEnum
    having?: PermisoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermisoCountAggregateInputType | true
    _avg?: PermisoAvgAggregateInputType
    _sum?: PermisoSumAggregateInputType
    _min?: PermisoMinAggregateInputType
    _max?: PermisoMaxAggregateInputType
  }

  export type PermisoGroupByOutputType = {
    id: number
    permiso: string
    descripcion: string
    _count: PermisoCountAggregateOutputType | null
    _avg: PermisoAvgAggregateOutputType | null
    _sum: PermisoSumAggregateOutputType | null
    _min: PermisoMinAggregateOutputType | null
    _max: PermisoMaxAggregateOutputType | null
  }

  type GetPermisoGroupByPayload<T extends PermisoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermisoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermisoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermisoGroupByOutputType[P]>
            : GetScalarType<T[P], PermisoGroupByOutputType[P]>
        }
      >
    >


  export type PermisoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    permiso?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["permiso"]>

  export type PermisoSelectScalar = {
    id?: boolean
    permiso?: boolean
    descripcion?: boolean
  }


  export type $PermisoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permiso"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      permiso: string
      descripcion: string
    }, ExtArgs["result"]["permiso"]>
    composites: {}
  }


  type PermisoGetPayload<S extends boolean | null | undefined | PermisoDefaultArgs> = $Result.GetResult<Prisma.$PermisoPayload, S>

  type PermisoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermisoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermisoCountAggregateInputType | true
    }

  export interface PermisoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permiso'], meta: { name: 'Permiso' } }
    /**
     * Find zero or one Permiso that matches the filter.
     * @param {PermisoFindUniqueArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PermisoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoFindUniqueArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Permiso that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PermisoFindUniqueOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PermisoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Permiso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PermisoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoFindFirstArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Permiso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindFirstOrThrowArgs} args - Arguments to find a Permiso
     * @example
     * // Get one Permiso
     * const permiso = await prisma.permiso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PermisoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Permisos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permisos
     * const permisos = await prisma.permiso.findMany()
     * 
     * // Get first 10 Permisos
     * const permisos = await prisma.permiso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permisoWithIdOnly = await prisma.permiso.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PermisoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Permiso.
     * @param {PermisoCreateArgs} args - Arguments to create a Permiso.
     * @example
     * // Create one Permiso
     * const Permiso = await prisma.permiso.create({
     *   data: {
     *     // ... data to create a Permiso
     *   }
     * })
     * 
    **/
    create<T extends PermisoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoCreateArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Permisos.
     *     @param {PermisoCreateManyArgs} args - Arguments to create many Permisos.
     *     @example
     *     // Create many Permisos
     *     const permiso = await prisma.permiso.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PermisoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permiso.
     * @param {PermisoDeleteArgs} args - Arguments to delete one Permiso.
     * @example
     * // Delete one Permiso
     * const Permiso = await prisma.permiso.delete({
     *   where: {
     *     // ... filter to delete one Permiso
     *   }
     * })
     * 
    **/
    delete<T extends PermisoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoDeleteArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Permiso.
     * @param {PermisoUpdateArgs} args - Arguments to update one Permiso.
     * @example
     * // Update one Permiso
     * const permiso = await prisma.permiso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PermisoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoUpdateArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Permisos.
     * @param {PermisoDeleteManyArgs} args - Arguments to filter Permisos to delete.
     * @example
     * // Delete a few Permisos
     * const { count } = await prisma.permiso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PermisoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PermisoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permisos
     * const permiso = await prisma.permiso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PermisoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permiso.
     * @param {PermisoUpsertArgs} args - Arguments to update or create a Permiso.
     * @example
     * // Update or create a Permiso
     * const permiso = await prisma.permiso.upsert({
     *   create: {
     *     // ... data to create a Permiso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permiso we want to update
     *   }
     * })
    **/
    upsert<T extends PermisoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PermisoUpsertArgs<ExtArgs>>
    ): Prisma__PermisoClient<$Result.GetResult<Prisma.$PermisoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Permisos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoCountArgs} args - Arguments to filter Permisos to count.
     * @example
     * // Count the number of Permisos
     * const count = await prisma.permiso.count({
     *   where: {
     *     // ... the filter for the Permisos we want to count
     *   }
     * })
    **/
    count<T extends PermisoCountArgs>(
      args?: Subset<T, PermisoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermisoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermisoAggregateArgs>(args: Subset<T, PermisoAggregateArgs>): Prisma.PrismaPromise<GetPermisoAggregateType<T>>

    /**
     * Group by Permiso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermisoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermisoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermisoGroupByArgs['orderBy'] }
        : { orderBy?: PermisoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermisoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermisoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permiso model
   */
  readonly fields: PermisoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permiso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermisoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Permiso model
   */ 
  interface PermisoFieldRefs {
    readonly id: FieldRef<"Permiso", 'Int'>
    readonly permiso: FieldRef<"Permiso", 'String'>
    readonly descripcion: FieldRef<"Permiso", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Permiso findUnique
   */
  export type PermisoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }


  /**
   * Permiso findUniqueOrThrow
   */
  export type PermisoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where: PermisoWhereUniqueInput
  }


  /**
   * Permiso findFirst
   */
  export type PermisoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * Permiso findFirstOrThrow
   */
  export type PermisoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter, which Permiso to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permisos.
     */
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * Permiso findMany
   */
  export type PermisoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter, which Permisos to fetch.
     */
    where?: PermisoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permisos to fetch.
     */
    orderBy?: PermisoOrderByWithRelationInput | PermisoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permisos.
     */
    cursor?: PermisoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permisos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permisos.
     */
    skip?: number
    distinct?: PermisoScalarFieldEnum | PermisoScalarFieldEnum[]
  }


  /**
   * Permiso create
   */
  export type PermisoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * The data needed to create a Permiso.
     */
    data: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
  }


  /**
   * Permiso createMany
   */
  export type PermisoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permisos.
     */
    data: PermisoCreateManyInput | PermisoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Permiso update
   */
  export type PermisoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * The data needed to update a Permiso.
     */
    data: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
    /**
     * Choose, which Permiso to update.
     */
    where: PermisoWhereUniqueInput
  }


  /**
   * Permiso updateMany
   */
  export type PermisoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permisos.
     */
    data: XOR<PermisoUpdateManyMutationInput, PermisoUncheckedUpdateManyInput>
    /**
     * Filter which Permisos to update
     */
    where?: PermisoWhereInput
  }


  /**
   * Permiso upsert
   */
  export type PermisoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * The filter to search for the Permiso to update in case it exists.
     */
    where: PermisoWhereUniqueInput
    /**
     * In case the Permiso found by the `where` argument doesn't exist, create a new Permiso with this data.
     */
    create: XOR<PermisoCreateInput, PermisoUncheckedCreateInput>
    /**
     * In case the Permiso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermisoUpdateInput, PermisoUncheckedUpdateInput>
  }


  /**
   * Permiso delete
   */
  export type PermisoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
    /**
     * Filter which Permiso to delete.
     */
    where: PermisoWhereUniqueInput
  }


  /**
   * Permiso deleteMany
   */
  export type PermisoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permisos to delete
     */
    where?: PermisoWhereInput
  }


  /**
   * Permiso without action
   */
  export type PermisoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permiso
     */
    select?: PermisoSelect<ExtArgs> | null
  }



  /**
   * Model Bitacora
   */

  export type AggregateBitacora = {
    _count: BitacoraCountAggregateOutputType | null
    _avg: BitacoraAvgAggregateOutputType | null
    _sum: BitacoraSumAggregateOutputType | null
    _min: BitacoraMinAggregateOutputType | null
    _max: BitacoraMaxAggregateOutputType | null
  }

  export type BitacoraAvgAggregateOutputType = {
    id: number | null
    id_registro: number | null
  }

  export type BitacoraSumAggregateOutputType = {
    id: number | null
    id_registro: number | null
  }

  export type BitacoraMinAggregateOutputType = {
    id: number | null
    fecha_hora: Date | null
    usuario: string | null
    accion: string | null
    tabla: string | null
    id_registro: number | null
    descripcion: string | null
  }

  export type BitacoraMaxAggregateOutputType = {
    id: number | null
    fecha_hora: Date | null
    usuario: string | null
    accion: string | null
    tabla: string | null
    id_registro: number | null
    descripcion: string | null
  }

  export type BitacoraCountAggregateOutputType = {
    id: number
    fecha_hora: number
    usuario: number
    accion: number
    tabla: number
    id_registro: number
    descripcion: number
    _all: number
  }


  export type BitacoraAvgAggregateInputType = {
    id?: true
    id_registro?: true
  }

  export type BitacoraSumAggregateInputType = {
    id?: true
    id_registro?: true
  }

  export type BitacoraMinAggregateInputType = {
    id?: true
    fecha_hora?: true
    usuario?: true
    accion?: true
    tabla?: true
    id_registro?: true
    descripcion?: true
  }

  export type BitacoraMaxAggregateInputType = {
    id?: true
    fecha_hora?: true
    usuario?: true
    accion?: true
    tabla?: true
    id_registro?: true
    descripcion?: true
  }

  export type BitacoraCountAggregateInputType = {
    id?: true
    fecha_hora?: true
    usuario?: true
    accion?: true
    tabla?: true
    id_registro?: true
    descripcion?: true
    _all?: true
  }

  export type BitacoraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bitacora to aggregate.
     */
    where?: BitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bitacoras to fetch.
     */
    orderBy?: BitacoraOrderByWithRelationInput | BitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bitacoras
    **/
    _count?: true | BitacoraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BitacoraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BitacoraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BitacoraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BitacoraMaxAggregateInputType
  }

  export type GetBitacoraAggregateType<T extends BitacoraAggregateArgs> = {
        [P in keyof T & keyof AggregateBitacora]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBitacora[P]>
      : GetScalarType<T[P], AggregateBitacora[P]>
  }




  export type BitacoraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BitacoraWhereInput
    orderBy?: BitacoraOrderByWithAggregationInput | BitacoraOrderByWithAggregationInput[]
    by: BitacoraScalarFieldEnum[] | BitacoraScalarFieldEnum
    having?: BitacoraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BitacoraCountAggregateInputType | true
    _avg?: BitacoraAvgAggregateInputType
    _sum?: BitacoraSumAggregateInputType
    _min?: BitacoraMinAggregateInputType
    _max?: BitacoraMaxAggregateInputType
  }

  export type BitacoraGroupByOutputType = {
    id: number
    fecha_hora: Date
    usuario: string
    accion: string
    tabla: string | null
    id_registro: number | null
    descripcion: string | null
    _count: BitacoraCountAggregateOutputType | null
    _avg: BitacoraAvgAggregateOutputType | null
    _sum: BitacoraSumAggregateOutputType | null
    _min: BitacoraMinAggregateOutputType | null
    _max: BitacoraMaxAggregateOutputType | null
  }

  type GetBitacoraGroupByPayload<T extends BitacoraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BitacoraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BitacoraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BitacoraGroupByOutputType[P]>
            : GetScalarType<T[P], BitacoraGroupByOutputType[P]>
        }
      >
    >


  export type BitacoraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fecha_hora?: boolean
    usuario?: boolean
    accion?: boolean
    tabla?: boolean
    id_registro?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["bitacora"]>

  export type BitacoraSelectScalar = {
    id?: boolean
    fecha_hora?: boolean
    usuario?: boolean
    accion?: boolean
    tabla?: boolean
    id_registro?: boolean
    descripcion?: boolean
  }


  export type $BitacoraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bitacora"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fecha_hora: Date
      usuario: string
      accion: string
      tabla: string | null
      id_registro: number | null
      descripcion: string | null
    }, ExtArgs["result"]["bitacora"]>
    composites: {}
  }


  type BitacoraGetPayload<S extends boolean | null | undefined | BitacoraDefaultArgs> = $Result.GetResult<Prisma.$BitacoraPayload, S>

  type BitacoraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BitacoraFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BitacoraCountAggregateInputType | true
    }

  export interface BitacoraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bitacora'], meta: { name: 'Bitacora' } }
    /**
     * Find zero or one Bitacora that matches the filter.
     * @param {BitacoraFindUniqueArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends BitacoraFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraFindUniqueArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Bitacora that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {BitacoraFindUniqueOrThrowArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends BitacoraFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Bitacora that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraFindFirstArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends BitacoraFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraFindFirstArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Bitacora that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraFindFirstOrThrowArgs} args - Arguments to find a Bitacora
     * @example
     * // Get one Bitacora
     * const bitacora = await prisma.bitacora.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends BitacoraFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Bitacoras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bitacoras
     * const bitacoras = await prisma.bitacora.findMany()
     * 
     * // Get first 10 Bitacoras
     * const bitacoras = await prisma.bitacora.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bitacoraWithIdOnly = await prisma.bitacora.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends BitacoraFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Bitacora.
     * @param {BitacoraCreateArgs} args - Arguments to create a Bitacora.
     * @example
     * // Create one Bitacora
     * const Bitacora = await prisma.bitacora.create({
     *   data: {
     *     // ... data to create a Bitacora
     *   }
     * })
     * 
    **/
    create<T extends BitacoraCreateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraCreateArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Bitacoras.
     *     @param {BitacoraCreateManyArgs} args - Arguments to create many Bitacoras.
     *     @example
     *     // Create many Bitacoras
     *     const bitacora = await prisma.bitacora.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends BitacoraCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bitacora.
     * @param {BitacoraDeleteArgs} args - Arguments to delete one Bitacora.
     * @example
     * // Delete one Bitacora
     * const Bitacora = await prisma.bitacora.delete({
     *   where: {
     *     // ... filter to delete one Bitacora
     *   }
     * })
     * 
    **/
    delete<T extends BitacoraDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraDeleteArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Bitacora.
     * @param {BitacoraUpdateArgs} args - Arguments to update one Bitacora.
     * @example
     * // Update one Bitacora
     * const bitacora = await prisma.bitacora.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends BitacoraUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraUpdateArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Bitacoras.
     * @param {BitacoraDeleteManyArgs} args - Arguments to filter Bitacoras to delete.
     * @example
     * // Delete a few Bitacoras
     * const { count } = await prisma.bitacora.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends BitacoraDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, BitacoraDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bitacoras
     * const bitacora = await prisma.bitacora.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends BitacoraUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bitacora.
     * @param {BitacoraUpsertArgs} args - Arguments to update or create a Bitacora.
     * @example
     * // Update or create a Bitacora
     * const bitacora = await prisma.bitacora.upsert({
     *   create: {
     *     // ... data to create a Bitacora
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bitacora we want to update
     *   }
     * })
    **/
    upsert<T extends BitacoraUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, BitacoraUpsertArgs<ExtArgs>>
    ): Prisma__BitacoraClient<$Result.GetResult<Prisma.$BitacoraPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Bitacoras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraCountArgs} args - Arguments to filter Bitacoras to count.
     * @example
     * // Count the number of Bitacoras
     * const count = await prisma.bitacora.count({
     *   where: {
     *     // ... the filter for the Bitacoras we want to count
     *   }
     * })
    **/
    count<T extends BitacoraCountArgs>(
      args?: Subset<T, BitacoraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BitacoraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BitacoraAggregateArgs>(args: Subset<T, BitacoraAggregateArgs>): Prisma.PrismaPromise<GetBitacoraAggregateType<T>>

    /**
     * Group by Bitacora.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BitacoraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BitacoraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BitacoraGroupByArgs['orderBy'] }
        : { orderBy?: BitacoraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BitacoraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBitacoraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bitacora model
   */
  readonly fields: BitacoraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bitacora.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BitacoraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Bitacora model
   */ 
  interface BitacoraFieldRefs {
    readonly id: FieldRef<"Bitacora", 'Int'>
    readonly fecha_hora: FieldRef<"Bitacora", 'DateTime'>
    readonly usuario: FieldRef<"Bitacora", 'String'>
    readonly accion: FieldRef<"Bitacora", 'String'>
    readonly tabla: FieldRef<"Bitacora", 'String'>
    readonly id_registro: FieldRef<"Bitacora", 'Int'>
    readonly descripcion: FieldRef<"Bitacora", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Bitacora findUnique
   */
  export type BitacoraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter, which Bitacora to fetch.
     */
    where: BitacoraWhereUniqueInput
  }


  /**
   * Bitacora findUniqueOrThrow
   */
  export type BitacoraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter, which Bitacora to fetch.
     */
    where: BitacoraWhereUniqueInput
  }


  /**
   * Bitacora findFirst
   */
  export type BitacoraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter, which Bitacora to fetch.
     */
    where?: BitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bitacoras to fetch.
     */
    orderBy?: BitacoraOrderByWithRelationInput | BitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bitacoras.
     */
    cursor?: BitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bitacoras.
     */
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }


  /**
   * Bitacora findFirstOrThrow
   */
  export type BitacoraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter, which Bitacora to fetch.
     */
    where?: BitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bitacoras to fetch.
     */
    orderBy?: BitacoraOrderByWithRelationInput | BitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bitacoras.
     */
    cursor?: BitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bitacoras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bitacoras.
     */
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }


  /**
   * Bitacora findMany
   */
  export type BitacoraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter, which Bitacoras to fetch.
     */
    where?: BitacoraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bitacoras to fetch.
     */
    orderBy?: BitacoraOrderByWithRelationInput | BitacoraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bitacoras.
     */
    cursor?: BitacoraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bitacoras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bitacoras.
     */
    skip?: number
    distinct?: BitacoraScalarFieldEnum | BitacoraScalarFieldEnum[]
  }


  /**
   * Bitacora create
   */
  export type BitacoraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * The data needed to create a Bitacora.
     */
    data: XOR<BitacoraCreateInput, BitacoraUncheckedCreateInput>
  }


  /**
   * Bitacora createMany
   */
  export type BitacoraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bitacoras.
     */
    data: BitacoraCreateManyInput | BitacoraCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Bitacora update
   */
  export type BitacoraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * The data needed to update a Bitacora.
     */
    data: XOR<BitacoraUpdateInput, BitacoraUncheckedUpdateInput>
    /**
     * Choose, which Bitacora to update.
     */
    where: BitacoraWhereUniqueInput
  }


  /**
   * Bitacora updateMany
   */
  export type BitacoraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bitacoras.
     */
    data: XOR<BitacoraUpdateManyMutationInput, BitacoraUncheckedUpdateManyInput>
    /**
     * Filter which Bitacoras to update
     */
    where?: BitacoraWhereInput
  }


  /**
   * Bitacora upsert
   */
  export type BitacoraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * The filter to search for the Bitacora to update in case it exists.
     */
    where: BitacoraWhereUniqueInput
    /**
     * In case the Bitacora found by the `where` argument doesn't exist, create a new Bitacora with this data.
     */
    create: XOR<BitacoraCreateInput, BitacoraUncheckedCreateInput>
    /**
     * In case the Bitacora was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BitacoraUpdateInput, BitacoraUncheckedUpdateInput>
  }


  /**
   * Bitacora delete
   */
  export type BitacoraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
    /**
     * Filter which Bitacora to delete.
     */
    where: BitacoraWhereUniqueInput
  }


  /**
   * Bitacora deleteMany
   */
  export type BitacoraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bitacoras to delete
     */
    where?: BitacoraWhereInput
  }


  /**
   * Bitacora without action
   */
  export type BitacoraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bitacora
     */
    select?: BitacoraSelect<ExtArgs> | null
  }



  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    Id: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    Id: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    Id: number | null
    Email: string | null
    Password: string | null
    IsAdministrator: boolean | null
    IsDoctor: boolean | null
    IsEmployee: boolean | null
  }

  export type UsuariosMaxAggregateOutputType = {
    Id: number | null
    Email: string | null
    Password: string | null
    IsAdministrator: boolean | null
    IsDoctor: boolean | null
    IsEmployee: boolean | null
  }

  export type UsuariosCountAggregateOutputType = {
    Id: number
    Email: number
    Password: number
    IsAdministrator: number
    IsDoctor: number
    IsEmployee: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    Id?: true
  }

  export type UsuariosSumAggregateInputType = {
    Id?: true
  }

  export type UsuariosMinAggregateInputType = {
    Id?: true
    Email?: true
    Password?: true
    IsAdministrator?: true
    IsDoctor?: true
    IsEmployee?: true
  }

  export type UsuariosMaxAggregateInputType = {
    Id?: true
    Email?: true
    Password?: true
    IsAdministrator?: true
    IsDoctor?: true
    IsEmployee?: true
  }

  export type UsuariosCountAggregateInputType = {
    Id?: true
    Email?: true
    Password?: true
    IsAdministrator?: true
    IsDoctor?: true
    IsEmployee?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    Id: number
    Email: string
    Password: string
    IsAdministrator: boolean
    IsDoctor: boolean
    IsEmployee: boolean
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Email?: boolean
    Password?: boolean
    IsAdministrator?: boolean
    IsDoctor?: boolean
    IsEmployee?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectScalar = {
    Id?: boolean
    Email?: boolean
    Password?: boolean
    IsAdministrator?: boolean
    IsDoctor?: boolean
    IsEmployee?: boolean
  }


  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Email: string
      Password: string
      IsAdministrator: boolean
      IsDoctor: boolean
      IsEmployee: boolean
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }


  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UsuariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Usuarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UsuariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { Id: true } })
     * 
    **/
    findMany<T extends UsuariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
    **/
    create<T extends UsuariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Usuarios.
     *     @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     *     @example
     *     // Create many Usuarios
     *     const usuarios = await prisma.usuarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UsuariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
    **/
    delete<T extends UsuariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UsuariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UsuariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UsuariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
    **/
    upsert<T extends UsuariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>
    ): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Usuarios model
   */ 
  interface UsuariosFieldRefs {
    readonly Id: FieldRef<"Usuarios", 'Int'>
    readonly Email: FieldRef<"Usuarios", 'String'>
    readonly Password: FieldRef<"Usuarios", 'String'>
    readonly IsAdministrator: FieldRef<"Usuarios", 'Boolean'>
    readonly IsDoctor: FieldRef<"Usuarios", 'Boolean'>
    readonly IsEmployee: FieldRef<"Usuarios", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }


  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }


  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }


  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }


  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
  }


  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    edad: 'edad',
    fecha_nacimiento: 'fecha_nacimiento',
    genero: 'genero',
    especialidad: 'especialidad',
    direccion: 'direccion',
    telefono: 'telefono',
    celular: 'celular',
    curp: 'curp',
    cedula: 'cedula',
    sexo: 'sexo',
    licencia_medica: 'licencia_medica',
    correo_electronico: 'correo_electronico'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const EmpleadoScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    fecha_nacimiento: 'fecha_nacimiento',
    genero: 'genero',
    telefono: 'telefono',
    correo_electronico: 'correo_electronico',
    direccion: 'direccion',
    puesto: 'puesto',
    curp: 'curp',
    rfc: 'rfc',
    salario: 'salario',
    fecha_contratacion: 'fecha_contratacion'
  };

  export type EmpleadoScalarFieldEnum = (typeof EmpleadoScalarFieldEnum)[keyof typeof EmpleadoScalarFieldEnum]


  export const ClientesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    apellido: 'apellido',
    sexo: 'sexo',
    edad: 'edad',
    fecha_nacimiento: 'fecha_nacimiento',
    domicilio: 'domicilio',
    telefono: 'telefono',
    curp: 'curp',
    correo_electronico: 'correo_electronico',
    tipo_sangre: 'tipo_sangre',
    ocupacion: 'ocupacion',
    escolaridad: 'escolaridad'
  };

  export type ClientesScalarFieldEnum = (typeof ClientesScalarFieldEnum)[keyof typeof ClientesScalarFieldEnum]


  export const EnfermedadesScalarFieldEnum: {
    id_enfermedad: 'id_enfermedad',
    tipo: 'tipo',
    otro: 'otro',
    causas: 'causas',
    sintomas: 'sintomas',
    tratamiento: 'tratamiento'
  };

  export type EnfermedadesScalarFieldEnum = (typeof EnfermedadesScalarFieldEnum)[keyof typeof EnfermedadesScalarFieldEnum]


  export const AntecedentesNoPatologicosScalarFieldEnum: {
    id_paciente: 'id_paciente',
    tabaquismo: 'tabaquismo',
    toxicomanias: 'toxicomanias',
    alcoholismo: 'alcoholismo',
    sedentarismo: 'sedentarismo',
    cirugias: 'cirugias',
    ejercicio: 'ejercicio'
  };

  export type AntecedentesNoPatologicosScalarFieldEnum = (typeof AntecedentesNoPatologicosScalarFieldEnum)[keyof typeof AntecedentesNoPatologicosScalarFieldEnum]


  export const AntecedentesPatologicosScalarFieldEnum: {
    id: 'id',
    paciente_id: 'paciente_id',
    enfermedad: 'enfermedad',
    fecha_diagnostico: 'fecha_diagnostico',
    tipo_enfermedad: 'tipo_enfermedad',
    cronica: 'cronica',
    tratamiento: 'tratamiento',
    observaciones: 'observaciones'
  };

  export type AntecedentesPatologicosScalarFieldEnum = (typeof AntecedentesPatologicosScalarFieldEnum)[keyof typeof AntecedentesPatologicosScalarFieldEnum]


  export const ExamenClinicoIntraoralScalarFieldEnum: {
    id_paciente: 'id_paciente',
    fecha_examen: 'fecha_examen',
    encia: 'encia',
    lengua: 'lengua',
    paladar_duro: 'paladar_duro',
    paladar_blando: 'paladar_blando',
    faringe: 'faringe',
    piso_de_la_boca: 'piso_de_la_boca',
    reborde_residual: 'reborde_residual',
    tipo_oclusion: 'tipo_oclusion',
    observaciones: 'observaciones'
  };

  export type ExamenClinicoIntraoralScalarFieldEnum = (typeof ExamenClinicoIntraoralScalarFieldEnum)[keyof typeof ExamenClinicoIntraoralScalarFieldEnum]


  export const HistorialClinicoScalarFieldEnum: {
    id: 'id',
    cliente_id: 'cliente_id',
    dentista_id: 'dentista_id',
    fecha_consulta: 'fecha_consulta',
    datos_clinicos: 'datos_clinicos'
  };

  export type HistorialClinicoScalarFieldEnum = (typeof HistorialClinicoScalarFieldEnum)[keyof typeof HistorialClinicoScalarFieldEnum]


  export const PermisoScalarFieldEnum: {
    id: 'id',
    permiso: 'permiso',
    descripcion: 'descripcion'
  };

  export type PermisoScalarFieldEnum = (typeof PermisoScalarFieldEnum)[keyof typeof PermisoScalarFieldEnum]


  export const BitacoraScalarFieldEnum: {
    id: 'id',
    fecha_hora: 'fecha_hora',
    usuario: 'usuario',
    accion: 'accion',
    tabla: 'tabla',
    id_registro: 'id_registro',
    descripcion: 'descripcion'
  };

  export type BitacoraScalarFieldEnum = (typeof BitacoraScalarFieldEnum)[keyof typeof BitacoraScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    Id: 'Id',
    Email: 'Email',
    Password: 'Password',
    IsAdministrator: 'IsAdministrator',
    IsDoctor: 'IsDoctor',
    IsEmployee: 'IsEmployee'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'GeneroEnum'
   */
  export type EnumGeneroEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'GeneroEnum'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'TipoEnfermedadEnum'
   */
  export type EnumTipoEnfermedadEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEnfermedadEnum'>
    


  /**
   * Reference to a field of type 'SiNoEnum'
   */
  export type EnumSiNoEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SiNoEnum'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: IntFilter<"Doctor"> | number
    nombre?: StringFilter<"Doctor"> | string
    apellido?: StringFilter<"Doctor"> | string
    edad?: IntNullableFilter<"Doctor"> | number | null
    fecha_nacimiento?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    genero?: EnumGeneroEnumNullableFilter<"Doctor"> | $Enums.GeneroEnum | null
    especialidad?: StringNullableFilter<"Doctor"> | string | null
    direccion?: StringNullableFilter<"Doctor"> | string | null
    telefono?: StringNullableFilter<"Doctor"> | string | null
    celular?: StringNullableFilter<"Doctor"> | string | null
    curp?: StringNullableFilter<"Doctor"> | string | null
    cedula?: StringNullableFilter<"Doctor"> | string | null
    sexo?: StringNullableFilter<"Doctor"> | string | null
    licencia_medica?: StringNullableFilter<"Doctor"> | string | null
    correo_electronico?: StringNullableFilter<"Doctor"> | string | null
    historiales_clinicos?: HistorialClinicoListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    especialidad?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    licencia_medica?: SortOrderInput | SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    historiales_clinicos?: HistorialClinicoOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    nombre?: StringFilter<"Doctor"> | string
    apellido?: StringFilter<"Doctor"> | string
    edad?: IntNullableFilter<"Doctor"> | number | null
    fecha_nacimiento?: DateTimeNullableFilter<"Doctor"> | Date | string | null
    genero?: EnumGeneroEnumNullableFilter<"Doctor"> | $Enums.GeneroEnum | null
    especialidad?: StringNullableFilter<"Doctor"> | string | null
    direccion?: StringNullableFilter<"Doctor"> | string | null
    telefono?: StringNullableFilter<"Doctor"> | string | null
    celular?: StringNullableFilter<"Doctor"> | string | null
    curp?: StringNullableFilter<"Doctor"> | string | null
    cedula?: StringNullableFilter<"Doctor"> | string | null
    sexo?: StringNullableFilter<"Doctor"> | string | null
    licencia_medica?: StringNullableFilter<"Doctor"> | string | null
    correo_electronico?: StringNullableFilter<"Doctor"> | string | null
    historiales_clinicos?: HistorialClinicoListRelationFilter
  }, "id">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edad?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    especialidad?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    celular?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    cedula?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    licencia_medica?: SortOrderInput | SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _avg?: DoctorAvgOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
    _sum?: DoctorSumOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Doctor"> | number
    nombre?: StringWithAggregatesFilter<"Doctor"> | string
    apellido?: StringWithAggregatesFilter<"Doctor"> | string
    edad?: IntNullableWithAggregatesFilter<"Doctor"> | number | null
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"Doctor"> | Date | string | null
    genero?: EnumGeneroEnumNullableWithAggregatesFilter<"Doctor"> | $Enums.GeneroEnum | null
    especialidad?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    celular?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    curp?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    cedula?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    sexo?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    licencia_medica?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    correo_electronico?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
  }

  export type EmpleadoWhereInput = {
    AND?: EmpleadoWhereInput | EmpleadoWhereInput[]
    OR?: EmpleadoWhereInput[]
    NOT?: EmpleadoWhereInput | EmpleadoWhereInput[]
    id?: IntFilter<"Empleado"> | number
    nombre?: StringFilter<"Empleado"> | string
    apellido?: StringFilter<"Empleado"> | string
    fecha_nacimiento?: DateTimeNullableFilter<"Empleado"> | Date | string | null
    genero?: EnumGeneroEnumNullableFilter<"Empleado"> | $Enums.GeneroEnum | null
    telefono?: StringNullableFilter<"Empleado"> | string | null
    correo_electronico?: StringNullableFilter<"Empleado"> | string | null
    direccion?: StringNullableFilter<"Empleado"> | string | null
    puesto?: StringNullableFilter<"Empleado"> | string | null
    curp?: StringNullableFilter<"Empleado"> | string | null
    rfc?: StringNullableFilter<"Empleado"> | string | null
    salario?: FloatNullableFilter<"Empleado"> | number | null
    fecha_contratacion?: DateTimeNullableFilter<"Empleado"> | Date | string | null
  }

  export type EmpleadoOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    fecha_contratacion?: SortOrderInput | SortOrder
  }

  export type EmpleadoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EmpleadoWhereInput | EmpleadoWhereInput[]
    OR?: EmpleadoWhereInput[]
    NOT?: EmpleadoWhereInput | EmpleadoWhereInput[]
    nombre?: StringFilter<"Empleado"> | string
    apellido?: StringFilter<"Empleado"> | string
    fecha_nacimiento?: DateTimeNullableFilter<"Empleado"> | Date | string | null
    genero?: EnumGeneroEnumNullableFilter<"Empleado"> | $Enums.GeneroEnum | null
    telefono?: StringNullableFilter<"Empleado"> | string | null
    correo_electronico?: StringNullableFilter<"Empleado"> | string | null
    direccion?: StringNullableFilter<"Empleado"> | string | null
    puesto?: StringNullableFilter<"Empleado"> | string | null
    curp?: StringNullableFilter<"Empleado"> | string | null
    rfc?: StringNullableFilter<"Empleado"> | string | null
    salario?: FloatNullableFilter<"Empleado"> | number | null
    fecha_contratacion?: DateTimeNullableFilter<"Empleado"> | Date | string | null
  }, "id">

  export type EmpleadoOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    genero?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    direccion?: SortOrderInput | SortOrder
    puesto?: SortOrderInput | SortOrder
    curp?: SortOrderInput | SortOrder
    rfc?: SortOrderInput | SortOrder
    salario?: SortOrderInput | SortOrder
    fecha_contratacion?: SortOrderInput | SortOrder
    _count?: EmpleadoCountOrderByAggregateInput
    _avg?: EmpleadoAvgOrderByAggregateInput
    _max?: EmpleadoMaxOrderByAggregateInput
    _min?: EmpleadoMinOrderByAggregateInput
    _sum?: EmpleadoSumOrderByAggregateInput
  }

  export type EmpleadoScalarWhereWithAggregatesInput = {
    AND?: EmpleadoScalarWhereWithAggregatesInput | EmpleadoScalarWhereWithAggregatesInput[]
    OR?: EmpleadoScalarWhereWithAggregatesInput[]
    NOT?: EmpleadoScalarWhereWithAggregatesInput | EmpleadoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Empleado"> | number
    nombre?: StringWithAggregatesFilter<"Empleado"> | string
    apellido?: StringWithAggregatesFilter<"Empleado"> | string
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"Empleado"> | Date | string | null
    genero?: EnumGeneroEnumNullableWithAggregatesFilter<"Empleado"> | $Enums.GeneroEnum | null
    telefono?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    correo_electronico?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    direccion?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    puesto?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    curp?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    rfc?: StringNullableWithAggregatesFilter<"Empleado"> | string | null
    salario?: FloatNullableWithAggregatesFilter<"Empleado"> | number | null
    fecha_contratacion?: DateTimeNullableWithAggregatesFilter<"Empleado"> | Date | string | null
  }

  export type ClientesWhereInput = {
    AND?: ClientesWhereInput | ClientesWhereInput[]
    OR?: ClientesWhereInput[]
    NOT?: ClientesWhereInput | ClientesWhereInput[]
    id?: IntFilter<"Clientes"> | number
    nombre?: StringFilter<"Clientes"> | string
    apellido?: StringFilter<"Clientes"> | string
    sexo?: StringFilter<"Clientes"> | string
    edad?: IntFilter<"Clientes"> | number
    fecha_nacimiento?: DateTimeNullableFilter<"Clientes"> | Date | string | null
    domicilio?: StringNullableFilter<"Clientes"> | string | null
    telefono?: StringNullableFilter<"Clientes"> | string | null
    curp?: StringFilter<"Clientes"> | string
    correo_electronico?: StringNullableFilter<"Clientes"> | string | null
    tipo_sangre?: StringFilter<"Clientes"> | string
    ocupacion?: StringFilter<"Clientes"> | string
    escolaridad?: StringFilter<"Clientes"> | string
    historial_clinico?: HistorialClinicoListRelationFilter
    antecedentesNoPatologicos?: AntecedentesNoPatologicosListRelationFilter
    antecedentesPatologicos?: AntecedentesPatologicosListRelationFilter
    examenesClinicosIntraorales?: ExamenClinicoIntraoralListRelationFilter
  }

  export type ClientesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    sexo?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    curp?: SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    tipo_sangre?: SortOrder
    ocupacion?: SortOrder
    escolaridad?: SortOrder
    historial_clinico?: HistorialClinicoOrderByRelationAggregateInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosOrderByRelationAggregateInput
    antecedentesPatologicos?: AntecedentesPatologicosOrderByRelationAggregateInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralOrderByRelationAggregateInput
  }

  export type ClientesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientesWhereInput | ClientesWhereInput[]
    OR?: ClientesWhereInput[]
    NOT?: ClientesWhereInput | ClientesWhereInput[]
    nombre?: StringFilter<"Clientes"> | string
    apellido?: StringFilter<"Clientes"> | string
    sexo?: StringFilter<"Clientes"> | string
    edad?: IntFilter<"Clientes"> | number
    fecha_nacimiento?: DateTimeNullableFilter<"Clientes"> | Date | string | null
    domicilio?: StringNullableFilter<"Clientes"> | string | null
    telefono?: StringNullableFilter<"Clientes"> | string | null
    curp?: StringFilter<"Clientes"> | string
    correo_electronico?: StringNullableFilter<"Clientes"> | string | null
    tipo_sangre?: StringFilter<"Clientes"> | string
    ocupacion?: StringFilter<"Clientes"> | string
    escolaridad?: StringFilter<"Clientes"> | string
    historial_clinico?: HistorialClinicoListRelationFilter
    antecedentesNoPatologicos?: AntecedentesNoPatologicosListRelationFilter
    antecedentesPatologicos?: AntecedentesPatologicosListRelationFilter
    examenesClinicosIntraorales?: ExamenClinicoIntraoralListRelationFilter
  }, "id">

  export type ClientesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    sexo?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    domicilio?: SortOrderInput | SortOrder
    telefono?: SortOrderInput | SortOrder
    curp?: SortOrder
    correo_electronico?: SortOrderInput | SortOrder
    tipo_sangre?: SortOrder
    ocupacion?: SortOrder
    escolaridad?: SortOrder
    _count?: ClientesCountOrderByAggregateInput
    _avg?: ClientesAvgOrderByAggregateInput
    _max?: ClientesMaxOrderByAggregateInput
    _min?: ClientesMinOrderByAggregateInput
    _sum?: ClientesSumOrderByAggregateInput
  }

  export type ClientesScalarWhereWithAggregatesInput = {
    AND?: ClientesScalarWhereWithAggregatesInput | ClientesScalarWhereWithAggregatesInput[]
    OR?: ClientesScalarWhereWithAggregatesInput[]
    NOT?: ClientesScalarWhereWithAggregatesInput | ClientesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Clientes"> | number
    nombre?: StringWithAggregatesFilter<"Clientes"> | string
    apellido?: StringWithAggregatesFilter<"Clientes"> | string
    sexo?: StringWithAggregatesFilter<"Clientes"> | string
    edad?: IntWithAggregatesFilter<"Clientes"> | number
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"Clientes"> | Date | string | null
    domicilio?: StringNullableWithAggregatesFilter<"Clientes"> | string | null
    telefono?: StringNullableWithAggregatesFilter<"Clientes"> | string | null
    curp?: StringWithAggregatesFilter<"Clientes"> | string
    correo_electronico?: StringNullableWithAggregatesFilter<"Clientes"> | string | null
    tipo_sangre?: StringWithAggregatesFilter<"Clientes"> | string
    ocupacion?: StringWithAggregatesFilter<"Clientes"> | string
    escolaridad?: StringWithAggregatesFilter<"Clientes"> | string
  }

  export type EnfermedadesWhereInput = {
    AND?: EnfermedadesWhereInput | EnfermedadesWhereInput[]
    OR?: EnfermedadesWhereInput[]
    NOT?: EnfermedadesWhereInput | EnfermedadesWhereInput[]
    id_enfermedad?: IntFilter<"Enfermedades"> | number
    tipo?: EnumTipoEnfermedadEnumFilter<"Enfermedades"> | $Enums.TipoEnfermedadEnum
    otro?: StringFilter<"Enfermedades"> | string
    causas?: StringFilter<"Enfermedades"> | string
    sintomas?: StringFilter<"Enfermedades"> | string
    tratamiento?: StringFilter<"Enfermedades"> | string
  }

  export type EnfermedadesOrderByWithRelationInput = {
    id_enfermedad?: SortOrder
    tipo?: SortOrder
    otro?: SortOrder
    causas?: SortOrder
    sintomas?: SortOrder
    tratamiento?: SortOrder
  }

  export type EnfermedadesWhereUniqueInput = Prisma.AtLeast<{
    id_enfermedad?: number
    AND?: EnfermedadesWhereInput | EnfermedadesWhereInput[]
    OR?: EnfermedadesWhereInput[]
    NOT?: EnfermedadesWhereInput | EnfermedadesWhereInput[]
    tipo?: EnumTipoEnfermedadEnumFilter<"Enfermedades"> | $Enums.TipoEnfermedadEnum
    otro?: StringFilter<"Enfermedades"> | string
    causas?: StringFilter<"Enfermedades"> | string
    sintomas?: StringFilter<"Enfermedades"> | string
    tratamiento?: StringFilter<"Enfermedades"> | string
  }, "id_enfermedad">

  export type EnfermedadesOrderByWithAggregationInput = {
    id_enfermedad?: SortOrder
    tipo?: SortOrder
    otro?: SortOrder
    causas?: SortOrder
    sintomas?: SortOrder
    tratamiento?: SortOrder
    _count?: EnfermedadesCountOrderByAggregateInput
    _avg?: EnfermedadesAvgOrderByAggregateInput
    _max?: EnfermedadesMaxOrderByAggregateInput
    _min?: EnfermedadesMinOrderByAggregateInput
    _sum?: EnfermedadesSumOrderByAggregateInput
  }

  export type EnfermedadesScalarWhereWithAggregatesInput = {
    AND?: EnfermedadesScalarWhereWithAggregatesInput | EnfermedadesScalarWhereWithAggregatesInput[]
    OR?: EnfermedadesScalarWhereWithAggregatesInput[]
    NOT?: EnfermedadesScalarWhereWithAggregatesInput | EnfermedadesScalarWhereWithAggregatesInput[]
    id_enfermedad?: IntWithAggregatesFilter<"Enfermedades"> | number
    tipo?: EnumTipoEnfermedadEnumWithAggregatesFilter<"Enfermedades"> | $Enums.TipoEnfermedadEnum
    otro?: StringWithAggregatesFilter<"Enfermedades"> | string
    causas?: StringWithAggregatesFilter<"Enfermedades"> | string
    sintomas?: StringWithAggregatesFilter<"Enfermedades"> | string
    tratamiento?: StringWithAggregatesFilter<"Enfermedades"> | string
  }

  export type AntecedentesNoPatologicosWhereInput = {
    AND?: AntecedentesNoPatologicosWhereInput | AntecedentesNoPatologicosWhereInput[]
    OR?: AntecedentesNoPatologicosWhereInput[]
    NOT?: AntecedentesNoPatologicosWhereInput | AntecedentesNoPatologicosWhereInput[]
    id_paciente?: IntFilter<"AntecedentesNoPatologicos"> | number
    tabaquismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    cirugias?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
    ejercicio?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }

  export type AntecedentesNoPatologicosOrderByWithRelationInput = {
    id_paciente?: SortOrder
    tabaquismo?: SortOrder
    toxicomanias?: SortOrder
    alcoholismo?: SortOrder
    sedentarismo?: SortOrder
    cirugias?: SortOrderInput | SortOrder
    ejercicio?: SortOrderInput | SortOrder
    paciente?: ClientesOrderByWithRelationInput
  }

  export type AntecedentesNoPatologicosWhereUniqueInput = Prisma.AtLeast<{
    id_paciente?: number
    AND?: AntecedentesNoPatologicosWhereInput | AntecedentesNoPatologicosWhereInput[]
    OR?: AntecedentesNoPatologicosWhereInput[]
    NOT?: AntecedentesNoPatologicosWhereInput | AntecedentesNoPatologicosWhereInput[]
    tabaquismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    cirugias?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
    ejercicio?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }, "id_paciente">

  export type AntecedentesNoPatologicosOrderByWithAggregationInput = {
    id_paciente?: SortOrder
    tabaquismo?: SortOrder
    toxicomanias?: SortOrder
    alcoholismo?: SortOrder
    sedentarismo?: SortOrder
    cirugias?: SortOrderInput | SortOrder
    ejercicio?: SortOrderInput | SortOrder
    _count?: AntecedentesNoPatologicosCountOrderByAggregateInput
    _avg?: AntecedentesNoPatologicosAvgOrderByAggregateInput
    _max?: AntecedentesNoPatologicosMaxOrderByAggregateInput
    _min?: AntecedentesNoPatologicosMinOrderByAggregateInput
    _sum?: AntecedentesNoPatologicosSumOrderByAggregateInput
  }

  export type AntecedentesNoPatologicosScalarWhereWithAggregatesInput = {
    AND?: AntecedentesNoPatologicosScalarWhereWithAggregatesInput | AntecedentesNoPatologicosScalarWhereWithAggregatesInput[]
    OR?: AntecedentesNoPatologicosScalarWhereWithAggregatesInput[]
    NOT?: AntecedentesNoPatologicosScalarWhereWithAggregatesInput | AntecedentesNoPatologicosScalarWhereWithAggregatesInput[]
    id_paciente?: IntWithAggregatesFilter<"AntecedentesNoPatologicos"> | number
    tabaquismo?: EnumSiNoEnumWithAggregatesFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumWithAggregatesFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumWithAggregatesFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumWithAggregatesFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    cirugias?: StringNullableWithAggregatesFilter<"AntecedentesNoPatologicos"> | string | null
    ejercicio?: StringNullableWithAggregatesFilter<"AntecedentesNoPatologicos"> | string | null
  }

  export type AntecedentesPatologicosWhereInput = {
    AND?: AntecedentesPatologicosWhereInput | AntecedentesPatologicosWhereInput[]
    OR?: AntecedentesPatologicosWhereInput[]
    NOT?: AntecedentesPatologicosWhereInput | AntecedentesPatologicosWhereInput[]
    id?: IntFilter<"AntecedentesPatologicos"> | number
    paciente_id?: IntFilter<"AntecedentesPatologicos"> | number
    enfermedad?: StringFilter<"AntecedentesPatologicos"> | string
    fecha_diagnostico?: DateTimeFilter<"AntecedentesPatologicos"> | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFilter<"AntecedentesPatologicos"> | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFilter<"AntecedentesPatologicos"> | $Enums.SiNoEnum
    tratamiento?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
    observaciones?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }

  export type AntecedentesPatologicosOrderByWithRelationInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    enfermedad?: SortOrder
    fecha_diagnostico?: SortOrder
    tipo_enfermedad?: SortOrder
    cronica?: SortOrder
    tratamiento?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    paciente?: ClientesOrderByWithRelationInput
  }

  export type AntecedentesPatologicosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AntecedentesPatologicosWhereInput | AntecedentesPatologicosWhereInput[]
    OR?: AntecedentesPatologicosWhereInput[]
    NOT?: AntecedentesPatologicosWhereInput | AntecedentesPatologicosWhereInput[]
    paciente_id?: IntFilter<"AntecedentesPatologicos"> | number
    enfermedad?: StringFilter<"AntecedentesPatologicos"> | string
    fecha_diagnostico?: DateTimeFilter<"AntecedentesPatologicos"> | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFilter<"AntecedentesPatologicos"> | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFilter<"AntecedentesPatologicos"> | $Enums.SiNoEnum
    tratamiento?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
    observaciones?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }, "id">

  export type AntecedentesPatologicosOrderByWithAggregationInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    enfermedad?: SortOrder
    fecha_diagnostico?: SortOrder
    tipo_enfermedad?: SortOrder
    cronica?: SortOrder
    tratamiento?: SortOrderInput | SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: AntecedentesPatologicosCountOrderByAggregateInput
    _avg?: AntecedentesPatologicosAvgOrderByAggregateInput
    _max?: AntecedentesPatologicosMaxOrderByAggregateInput
    _min?: AntecedentesPatologicosMinOrderByAggregateInput
    _sum?: AntecedentesPatologicosSumOrderByAggregateInput
  }

  export type AntecedentesPatologicosScalarWhereWithAggregatesInput = {
    AND?: AntecedentesPatologicosScalarWhereWithAggregatesInput | AntecedentesPatologicosScalarWhereWithAggregatesInput[]
    OR?: AntecedentesPatologicosScalarWhereWithAggregatesInput[]
    NOT?: AntecedentesPatologicosScalarWhereWithAggregatesInput | AntecedentesPatologicosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AntecedentesPatologicos"> | number
    paciente_id?: IntWithAggregatesFilter<"AntecedentesPatologicos"> | number
    enfermedad?: StringWithAggregatesFilter<"AntecedentesPatologicos"> | string
    fecha_diagnostico?: DateTimeWithAggregatesFilter<"AntecedentesPatologicos"> | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumWithAggregatesFilter<"AntecedentesPatologicos"> | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumWithAggregatesFilter<"AntecedentesPatologicos"> | $Enums.SiNoEnum
    tratamiento?: StringNullableWithAggregatesFilter<"AntecedentesPatologicos"> | string | null
    observaciones?: StringNullableWithAggregatesFilter<"AntecedentesPatologicos"> | string | null
  }

  export type ExamenClinicoIntraoralWhereInput = {
    AND?: ExamenClinicoIntraoralWhereInput | ExamenClinicoIntraoralWhereInput[]
    OR?: ExamenClinicoIntraoralWhereInput[]
    NOT?: ExamenClinicoIntraoralWhereInput | ExamenClinicoIntraoralWhereInput[]
    id_paciente?: IntFilter<"ExamenClinicoIntraoral"> | number
    fecha_examen?: DateTimeFilter<"ExamenClinicoIntraoral"> | Date | string
    encia?: StringFilter<"ExamenClinicoIntraoral"> | string
    lengua?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_duro?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_blando?: StringFilter<"ExamenClinicoIntraoral"> | string
    faringe?: StringFilter<"ExamenClinicoIntraoral"> | string
    piso_de_la_boca?: StringFilter<"ExamenClinicoIntraoral"> | string
    reborde_residual?: StringFilter<"ExamenClinicoIntraoral"> | string
    tipo_oclusion?: StringFilter<"ExamenClinicoIntraoral"> | string
    observaciones?: StringNullableFilter<"ExamenClinicoIntraoral"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }

  export type ExamenClinicoIntraoralOrderByWithRelationInput = {
    id_paciente?: SortOrder
    fecha_examen?: SortOrder
    encia?: SortOrder
    lengua?: SortOrder
    paladar_duro?: SortOrder
    paladar_blando?: SortOrder
    faringe?: SortOrder
    piso_de_la_boca?: SortOrder
    reborde_residual?: SortOrder
    tipo_oclusion?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    paciente?: ClientesOrderByWithRelationInput
  }

  export type ExamenClinicoIntraoralWhereUniqueInput = Prisma.AtLeast<{
    id_paciente?: number
    AND?: ExamenClinicoIntraoralWhereInput | ExamenClinicoIntraoralWhereInput[]
    OR?: ExamenClinicoIntraoralWhereInput[]
    NOT?: ExamenClinicoIntraoralWhereInput | ExamenClinicoIntraoralWhereInput[]
    fecha_examen?: DateTimeFilter<"ExamenClinicoIntraoral"> | Date | string
    encia?: StringFilter<"ExamenClinicoIntraoral"> | string
    lengua?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_duro?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_blando?: StringFilter<"ExamenClinicoIntraoral"> | string
    faringe?: StringFilter<"ExamenClinicoIntraoral"> | string
    piso_de_la_boca?: StringFilter<"ExamenClinicoIntraoral"> | string
    reborde_residual?: StringFilter<"ExamenClinicoIntraoral"> | string
    tipo_oclusion?: StringFilter<"ExamenClinicoIntraoral"> | string
    observaciones?: StringNullableFilter<"ExamenClinicoIntraoral"> | string | null
    paciente?: XOR<ClientesRelationFilter, ClientesWhereInput>
  }, "id_paciente">

  export type ExamenClinicoIntraoralOrderByWithAggregationInput = {
    id_paciente?: SortOrder
    fecha_examen?: SortOrder
    encia?: SortOrder
    lengua?: SortOrder
    paladar_duro?: SortOrder
    paladar_blando?: SortOrder
    faringe?: SortOrder
    piso_de_la_boca?: SortOrder
    reborde_residual?: SortOrder
    tipo_oclusion?: SortOrder
    observaciones?: SortOrderInput | SortOrder
    _count?: ExamenClinicoIntraoralCountOrderByAggregateInput
    _avg?: ExamenClinicoIntraoralAvgOrderByAggregateInput
    _max?: ExamenClinicoIntraoralMaxOrderByAggregateInput
    _min?: ExamenClinicoIntraoralMinOrderByAggregateInput
    _sum?: ExamenClinicoIntraoralSumOrderByAggregateInput
  }

  export type ExamenClinicoIntraoralScalarWhereWithAggregatesInput = {
    AND?: ExamenClinicoIntraoralScalarWhereWithAggregatesInput | ExamenClinicoIntraoralScalarWhereWithAggregatesInput[]
    OR?: ExamenClinicoIntraoralScalarWhereWithAggregatesInput[]
    NOT?: ExamenClinicoIntraoralScalarWhereWithAggregatesInput | ExamenClinicoIntraoralScalarWhereWithAggregatesInput[]
    id_paciente?: IntWithAggregatesFilter<"ExamenClinicoIntraoral"> | number
    fecha_examen?: DateTimeWithAggregatesFilter<"ExamenClinicoIntraoral"> | Date | string
    encia?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    lengua?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    paladar_duro?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    paladar_blando?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    faringe?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    piso_de_la_boca?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    reborde_residual?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    tipo_oclusion?: StringWithAggregatesFilter<"ExamenClinicoIntraoral"> | string
    observaciones?: StringNullableWithAggregatesFilter<"ExamenClinicoIntraoral"> | string | null
  }

  export type HistorialClinicoWhereInput = {
    AND?: HistorialClinicoWhereInput | HistorialClinicoWhereInput[]
    OR?: HistorialClinicoWhereInput[]
    NOT?: HistorialClinicoWhereInput | HistorialClinicoWhereInput[]
    id?: IntFilter<"HistorialClinico"> | number
    cliente_id?: IntFilter<"HistorialClinico"> | number
    dentista_id?: IntFilter<"HistorialClinico"> | number
    fecha_consulta?: DateTimeFilter<"HistorialClinico"> | Date | string
    datos_clinicos?: JsonFilter<"HistorialClinico">
    cliente?: XOR<ClientesRelationFilter, ClientesWhereInput>
    dentista?: XOR<DoctorRelationFilter, DoctorWhereInput>
  }

  export type HistorialClinicoOrderByWithRelationInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
    fecha_consulta?: SortOrder
    datos_clinicos?: SortOrder
    cliente?: ClientesOrderByWithRelationInput
    dentista?: DoctorOrderByWithRelationInput
  }

  export type HistorialClinicoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: HistorialClinicoWhereInput | HistorialClinicoWhereInput[]
    OR?: HistorialClinicoWhereInput[]
    NOT?: HistorialClinicoWhereInput | HistorialClinicoWhereInput[]
    cliente_id?: IntFilter<"HistorialClinico"> | number
    dentista_id?: IntFilter<"HistorialClinico"> | number
    fecha_consulta?: DateTimeFilter<"HistorialClinico"> | Date | string
    datos_clinicos?: JsonFilter<"HistorialClinico">
    cliente?: XOR<ClientesRelationFilter, ClientesWhereInput>
    dentista?: XOR<DoctorRelationFilter, DoctorWhereInput>
  }, "id">

  export type HistorialClinicoOrderByWithAggregationInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
    fecha_consulta?: SortOrder
    datos_clinicos?: SortOrder
    _count?: HistorialClinicoCountOrderByAggregateInput
    _avg?: HistorialClinicoAvgOrderByAggregateInput
    _max?: HistorialClinicoMaxOrderByAggregateInput
    _min?: HistorialClinicoMinOrderByAggregateInput
    _sum?: HistorialClinicoSumOrderByAggregateInput
  }

  export type HistorialClinicoScalarWhereWithAggregatesInput = {
    AND?: HistorialClinicoScalarWhereWithAggregatesInput | HistorialClinicoScalarWhereWithAggregatesInput[]
    OR?: HistorialClinicoScalarWhereWithAggregatesInput[]
    NOT?: HistorialClinicoScalarWhereWithAggregatesInput | HistorialClinicoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HistorialClinico"> | number
    cliente_id?: IntWithAggregatesFilter<"HistorialClinico"> | number
    dentista_id?: IntWithAggregatesFilter<"HistorialClinico"> | number
    fecha_consulta?: DateTimeWithAggregatesFilter<"HistorialClinico"> | Date | string
    datos_clinicos?: JsonWithAggregatesFilter<"HistorialClinico">
  }

  export type PermisoWhereInput = {
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    id?: IntFilter<"Permiso"> | number
    permiso?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
  }

  export type PermisoOrderByWithRelationInput = {
    id?: SortOrder
    permiso?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PermisoWhereInput | PermisoWhereInput[]
    OR?: PermisoWhereInput[]
    NOT?: PermisoWhereInput | PermisoWhereInput[]
    permiso?: StringFilter<"Permiso"> | string
    descripcion?: StringFilter<"Permiso"> | string
  }, "id">

  export type PermisoOrderByWithAggregationInput = {
    id?: SortOrder
    permiso?: SortOrder
    descripcion?: SortOrder
    _count?: PermisoCountOrderByAggregateInput
    _avg?: PermisoAvgOrderByAggregateInput
    _max?: PermisoMaxOrderByAggregateInput
    _min?: PermisoMinOrderByAggregateInput
    _sum?: PermisoSumOrderByAggregateInput
  }

  export type PermisoScalarWhereWithAggregatesInput = {
    AND?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    OR?: PermisoScalarWhereWithAggregatesInput[]
    NOT?: PermisoScalarWhereWithAggregatesInput | PermisoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Permiso"> | number
    permiso?: StringWithAggregatesFilter<"Permiso"> | string
    descripcion?: StringWithAggregatesFilter<"Permiso"> | string
  }

  export type BitacoraWhereInput = {
    AND?: BitacoraWhereInput | BitacoraWhereInput[]
    OR?: BitacoraWhereInput[]
    NOT?: BitacoraWhereInput | BitacoraWhereInput[]
    id?: IntFilter<"Bitacora"> | number
    fecha_hora?: DateTimeFilter<"Bitacora"> | Date | string
    usuario?: StringFilter<"Bitacora"> | string
    accion?: StringFilter<"Bitacora"> | string
    tabla?: StringNullableFilter<"Bitacora"> | string | null
    id_registro?: IntNullableFilter<"Bitacora"> | number | null
    descripcion?: StringNullableFilter<"Bitacora"> | string | null
  }

  export type BitacoraOrderByWithRelationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    usuario?: SortOrder
    accion?: SortOrder
    tabla?: SortOrderInput | SortOrder
    id_registro?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
  }

  export type BitacoraWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BitacoraWhereInput | BitacoraWhereInput[]
    OR?: BitacoraWhereInput[]
    NOT?: BitacoraWhereInput | BitacoraWhereInput[]
    fecha_hora?: DateTimeFilter<"Bitacora"> | Date | string
    usuario?: StringFilter<"Bitacora"> | string
    accion?: StringFilter<"Bitacora"> | string
    tabla?: StringNullableFilter<"Bitacora"> | string | null
    id_registro?: IntNullableFilter<"Bitacora"> | number | null
    descripcion?: StringNullableFilter<"Bitacora"> | string | null
  }, "id">

  export type BitacoraOrderByWithAggregationInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    usuario?: SortOrder
    accion?: SortOrder
    tabla?: SortOrderInput | SortOrder
    id_registro?: SortOrderInput | SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: BitacoraCountOrderByAggregateInput
    _avg?: BitacoraAvgOrderByAggregateInput
    _max?: BitacoraMaxOrderByAggregateInput
    _min?: BitacoraMinOrderByAggregateInput
    _sum?: BitacoraSumOrderByAggregateInput
  }

  export type BitacoraScalarWhereWithAggregatesInput = {
    AND?: BitacoraScalarWhereWithAggregatesInput | BitacoraScalarWhereWithAggregatesInput[]
    OR?: BitacoraScalarWhereWithAggregatesInput[]
    NOT?: BitacoraScalarWhereWithAggregatesInput | BitacoraScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Bitacora"> | number
    fecha_hora?: DateTimeWithAggregatesFilter<"Bitacora"> | Date | string
    usuario?: StringWithAggregatesFilter<"Bitacora"> | string
    accion?: StringWithAggregatesFilter<"Bitacora"> | string
    tabla?: StringNullableWithAggregatesFilter<"Bitacora"> | string | null
    id_registro?: IntNullableWithAggregatesFilter<"Bitacora"> | number | null
    descripcion?: StringNullableWithAggregatesFilter<"Bitacora"> | string | null
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    Id?: IntFilter<"Usuarios"> | number
    Email?: StringFilter<"Usuarios"> | string
    Password?: StringFilter<"Usuarios"> | string
    IsAdministrator?: BoolFilter<"Usuarios"> | boolean
    IsDoctor?: BoolFilter<"Usuarios"> | boolean
    IsEmployee?: BoolFilter<"Usuarios"> | boolean
  }

  export type UsuariosOrderByWithRelationInput = {
    Id?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    IsAdministrator?: SortOrder
    IsDoctor?: SortOrder
    IsEmployee?: SortOrder
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    Email?: string
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    Password?: StringFilter<"Usuarios"> | string
    IsAdministrator?: BoolFilter<"Usuarios"> | boolean
    IsDoctor?: BoolFilter<"Usuarios"> | boolean
    IsEmployee?: BoolFilter<"Usuarios"> | boolean
  }, "Id" | "Email">

  export type UsuariosOrderByWithAggregationInput = {
    Id?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    IsAdministrator?: SortOrder
    IsDoctor?: SortOrder
    IsEmployee?: SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _avg?: UsuariosAvgOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
    _sum?: UsuariosSumOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"Usuarios"> | number
    Email?: StringWithAggregatesFilter<"Usuarios"> | string
    Password?: StringWithAggregatesFilter<"Usuarios"> | string
    IsAdministrator?: BoolWithAggregatesFilter<"Usuarios"> | boolean
    IsDoctor?: BoolWithAggregatesFilter<"Usuarios"> | boolean
    IsEmployee?: BoolWithAggregatesFilter<"Usuarios"> | boolean
  }

  export type DoctorCreateInput = {
    nombre: string
    apellido: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    especialidad?: string | null
    direccion?: string | null
    telefono?: string | null
    celular?: string | null
    curp?: string | null
    cedula?: string | null
    sexo?: string | null
    licencia_medica?: string | null
    correo_electronico?: string | null
    historiales_clinicos?: HistorialClinicoCreateNestedManyWithoutDentistaInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    especialidad?: string | null
    direccion?: string | null
    telefono?: string | null
    celular?: string | null
    curp?: string | null
    cedula?: string | null
    sexo?: string | null
    licencia_medica?: string | null
    correo_electronico?: string | null
    historiales_clinicos?: HistorialClinicoUncheckedCreateNestedManyWithoutDentistaInput
  }

  export type DoctorUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    historiales_clinicos?: HistorialClinicoUpdateManyWithoutDentistaNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    historiales_clinicos?: HistorialClinicoUncheckedUpdateManyWithoutDentistaNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    especialidad?: string | null
    direccion?: string | null
    telefono?: string | null
    celular?: string | null
    curp?: string | null
    cedula?: string | null
    sexo?: string | null
    licencia_medica?: string | null
    correo_electronico?: string | null
  }

  export type DoctorUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmpleadoCreateInput = {
    nombre: string
    apellido: string
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    telefono?: string | null
    correo_electronico?: string | null
    direccion?: string | null
    puesto?: string | null
    curp?: string | null
    rfc?: string | null
    salario?: number | null
    fecha_contratacion?: Date | string | null
  }

  export type EmpleadoUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    telefono?: string | null
    correo_electronico?: string | null
    direccion?: string | null
    puesto?: string | null
    curp?: string | null
    rfc?: string | null
    salario?: number | null
    fecha_contratacion?: Date | string | null
  }

  export type EmpleadoUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_contratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpleadoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_contratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpleadoCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    telefono?: string | null
    correo_electronico?: string | null
    direccion?: string | null
    puesto?: string | null
    curp?: string | null
    rfc?: string | null
    salario?: number | null
    fecha_contratacion?: Date | string | null
  }

  export type EmpleadoUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_contratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmpleadoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    puesto?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    rfc?: NullableStringFieldUpdateOperationsInput | string | null
    salario?: NullableFloatFieldUpdateOperationsInput | number | null
    fecha_contratacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ClientesCreateInput = {
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUncheckedCreateInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoUncheckedCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUncheckedUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesCreateManyInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
  }

  export type ClientesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
  }

  export type ClientesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
  }

  export type EnfermedadesCreateInput = {
    tipo: $Enums.TipoEnfermedadEnum
    otro: string
    causas: string
    sintomas: string
    tratamiento: string
  }

  export type EnfermedadesUncheckedCreateInput = {
    id_enfermedad?: number
    tipo: $Enums.TipoEnfermedadEnum
    otro: string
    causas: string
    sintomas: string
    tratamiento: string
  }

  export type EnfermedadesUpdateInput = {
    tipo?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    otro?: StringFieldUpdateOperationsInput | string
    causas?: StringFieldUpdateOperationsInput | string
    sintomas?: StringFieldUpdateOperationsInput | string
    tratamiento?: StringFieldUpdateOperationsInput | string
  }

  export type EnfermedadesUncheckedUpdateInput = {
    id_enfermedad?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    otro?: StringFieldUpdateOperationsInput | string
    causas?: StringFieldUpdateOperationsInput | string
    sintomas?: StringFieldUpdateOperationsInput | string
    tratamiento?: StringFieldUpdateOperationsInput | string
  }

  export type EnfermedadesCreateManyInput = {
    id_enfermedad?: number
    tipo: $Enums.TipoEnfermedadEnum
    otro: string
    causas: string
    sintomas: string
    tratamiento: string
  }

  export type EnfermedadesUpdateManyMutationInput = {
    tipo?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    otro?: StringFieldUpdateOperationsInput | string
    causas?: StringFieldUpdateOperationsInput | string
    sintomas?: StringFieldUpdateOperationsInput | string
    tratamiento?: StringFieldUpdateOperationsInput | string
  }

  export type EnfermedadesUncheckedUpdateManyInput = {
    id_enfermedad?: IntFieldUpdateOperationsInput | number
    tipo?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    otro?: StringFieldUpdateOperationsInput | string
    causas?: StringFieldUpdateOperationsInput | string
    sintomas?: StringFieldUpdateOperationsInput | string
    tratamiento?: StringFieldUpdateOperationsInput | string
  }

  export type AntecedentesNoPatologicosCreateInput = {
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
    paciente: ClientesCreateNestedOneWithoutAntecedentesNoPatologicosInput
  }

  export type AntecedentesNoPatologicosUncheckedCreateInput = {
    id_paciente: number
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
  }

  export type AntecedentesNoPatologicosUpdateInput = {
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
    paciente?: ClientesUpdateOneRequiredWithoutAntecedentesNoPatologicosNestedInput
  }

  export type AntecedentesNoPatologicosUncheckedUpdateInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesNoPatologicosCreateManyInput = {
    id_paciente: number
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
  }

  export type AntecedentesNoPatologicosUpdateManyMutationInput = {
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesNoPatologicosUncheckedUpdateManyInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosCreateInput = {
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
    paciente: ClientesCreateNestedOneWithoutAntecedentesPatologicosInput
  }

  export type AntecedentesPatologicosUncheckedCreateInput = {
    id?: number
    paciente_id: number
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
  }

  export type AntecedentesPatologicosUpdateInput = {
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    paciente?: ClientesUpdateOneRequiredWithoutAntecedentesPatologicosNestedInput
  }

  export type AntecedentesPatologicosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: IntFieldUpdateOperationsInput | number
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosCreateManyInput = {
    id?: number
    paciente_id: number
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
  }

  export type AntecedentesPatologicosUpdateManyMutationInput = {
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    paciente_id?: IntFieldUpdateOperationsInput | number
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralCreateInput = {
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
    paciente: ClientesCreateNestedOneWithoutExamenesClinicosIntraoralesInput
  }

  export type ExamenClinicoIntraoralUncheckedCreateInput = {
    id_paciente: number
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
  }

  export type ExamenClinicoIntraoralUpdateInput = {
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
    paciente?: ClientesUpdateOneRequiredWithoutExamenesClinicosIntraoralesNestedInput
  }

  export type ExamenClinicoIntraoralUncheckedUpdateInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralCreateManyInput = {
    id_paciente: number
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
  }

  export type ExamenClinicoIntraoralUpdateManyMutationInput = {
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralUncheckedUpdateManyInput = {
    id_paciente?: IntFieldUpdateOperationsInput | number
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistorialClinicoCreateInput = {
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
    cliente: ClientesCreateNestedOneWithoutHistorial_clinicoInput
    dentista: DoctorCreateNestedOneWithoutHistoriales_clinicosInput
  }

  export type HistorialClinicoUncheckedCreateInput = {
    id?: number
    cliente_id: number
    dentista_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUpdateInput = {
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
    cliente?: ClientesUpdateOneRequiredWithoutHistorial_clinicoNestedInput
    dentista?: DoctorUpdateOneRequiredWithoutHistoriales_clinicosNestedInput
  }

  export type HistorialClinicoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliente_id?: IntFieldUpdateOperationsInput | number
    dentista_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoCreateManyInput = {
    id?: number
    cliente_id: number
    dentista_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUpdateManyMutationInput = {
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliente_id?: IntFieldUpdateOperationsInput | number
    dentista_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type PermisoCreateInput = {
    permiso: string
    descripcion: string
  }

  export type PermisoUncheckedCreateInput = {
    id?: number
    permiso: string
    descripcion: string
  }

  export type PermisoUpdateInput = {
    permiso?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    permiso?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoCreateManyInput = {
    id?: number
    permiso: string
    descripcion: string
  }

  export type PermisoUpdateManyMutationInput = {
    permiso?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type PermisoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    permiso?: StringFieldUpdateOperationsInput | string
    descripcion?: StringFieldUpdateOperationsInput | string
  }

  export type BitacoraCreateInput = {
    fecha_hora?: Date | string
    usuario: string
    accion: string
    tabla?: string | null
    id_registro?: number | null
    descripcion?: string | null
  }

  export type BitacoraUncheckedCreateInput = {
    id?: number
    fecha_hora?: Date | string
    usuario: string
    accion: string
    tabla?: string | null
    id_registro?: number | null
    descripcion?: string | null
  }

  export type BitacoraUpdateInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    tabla?: NullableStringFieldUpdateOperationsInput | string | null
    id_registro?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BitacoraUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    tabla?: NullableStringFieldUpdateOperationsInput | string | null
    id_registro?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BitacoraCreateManyInput = {
    id?: number
    fecha_hora?: Date | string
    usuario: string
    accion: string
    tabla?: string | null
    id_registro?: number | null
    descripcion?: string | null
  }

  export type BitacoraUpdateManyMutationInput = {
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    tabla?: NullableStringFieldUpdateOperationsInput | string | null
    id_registro?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BitacoraUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fecha_hora?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: StringFieldUpdateOperationsInput | string
    accion?: StringFieldUpdateOperationsInput | string
    tabla?: NullableStringFieldUpdateOperationsInput | string | null
    id_registro?: NullableIntFieldUpdateOperationsInput | number | null
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UsuariosCreateInput = {
    Email: string
    Password: string
    IsAdministrator?: boolean
    IsDoctor?: boolean
    IsEmployee?: boolean
  }

  export type UsuariosUncheckedCreateInput = {
    Id?: number
    Email: string
    Password: string
    IsAdministrator?: boolean
    IsDoctor?: boolean
    IsEmployee?: boolean
  }

  export type UsuariosUpdateInput = {
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdministrator?: BoolFieldUpdateOperationsInput | boolean
    IsDoctor?: BoolFieldUpdateOperationsInput | boolean
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuariosUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdministrator?: BoolFieldUpdateOperationsInput | boolean
    IsDoctor?: BoolFieldUpdateOperationsInput | boolean
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuariosCreateManyInput = {
    Id?: number
    Email: string
    Password: string
    IsAdministrator?: boolean
    IsDoctor?: boolean
    IsEmployee?: boolean
  }

  export type UsuariosUpdateManyMutationInput = {
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdministrator?: BoolFieldUpdateOperationsInput | boolean
    IsDoctor?: BoolFieldUpdateOperationsInput | boolean
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UsuariosUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    IsAdministrator?: BoolFieldUpdateOperationsInput | boolean
    IsDoctor?: BoolFieldUpdateOperationsInput | boolean
    IsEmployee?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumGeneroEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneroEnum | EnumGeneroEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GeneroEnum[] | null
    notIn?: $Enums.GeneroEnum[] | null
    not?: NestedEnumGeneroEnumNullableFilter<$PrismaModel> | $Enums.GeneroEnum | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type HistorialClinicoListRelationFilter = {
    every?: HistorialClinicoWhereInput
    some?: HistorialClinicoWhereInput
    none?: HistorialClinicoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type HistorialClinicoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    especialidad?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    curp?: SortOrder
    cedula?: SortOrder
    sexo?: SortOrder
    licencia_medica?: SortOrder
    correo_electronico?: SortOrder
  }

  export type DoctorAvgOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    especialidad?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    curp?: SortOrder
    cedula?: SortOrder
    sexo?: SortOrder
    licencia_medica?: SortOrder
    correo_electronico?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    especialidad?: SortOrder
    direccion?: SortOrder
    telefono?: SortOrder
    celular?: SortOrder
    curp?: SortOrder
    cedula?: SortOrder
    sexo?: SortOrder
    licencia_medica?: SortOrder
    correo_electronico?: SortOrder
  }

  export type DoctorSumOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumGeneroEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneroEnum | EnumGeneroEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GeneroEnum[] | null
    notIn?: $Enums.GeneroEnum[] | null
    not?: NestedEnumGeneroEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.GeneroEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGeneroEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumGeneroEnumNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EmpleadoCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    telefono?: SortOrder
    correo_electronico?: SortOrder
    direccion?: SortOrder
    puesto?: SortOrder
    curp?: SortOrder
    rfc?: SortOrder
    salario?: SortOrder
    fecha_contratacion?: SortOrder
  }

  export type EmpleadoAvgOrderByAggregateInput = {
    id?: SortOrder
    salario?: SortOrder
  }

  export type EmpleadoMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    telefono?: SortOrder
    correo_electronico?: SortOrder
    direccion?: SortOrder
    puesto?: SortOrder
    curp?: SortOrder
    rfc?: SortOrder
    salario?: SortOrder
    fecha_contratacion?: SortOrder
  }

  export type EmpleadoMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    fecha_nacimiento?: SortOrder
    genero?: SortOrder
    telefono?: SortOrder
    correo_electronico?: SortOrder
    direccion?: SortOrder
    puesto?: SortOrder
    curp?: SortOrder
    rfc?: SortOrder
    salario?: SortOrder
    fecha_contratacion?: SortOrder
  }

  export type EmpleadoSumOrderByAggregateInput = {
    id?: SortOrder
    salario?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AntecedentesNoPatologicosListRelationFilter = {
    every?: AntecedentesNoPatologicosWhereInput
    some?: AntecedentesNoPatologicosWhereInput
    none?: AntecedentesNoPatologicosWhereInput
  }

  export type AntecedentesPatologicosListRelationFilter = {
    every?: AntecedentesPatologicosWhereInput
    some?: AntecedentesPatologicosWhereInput
    none?: AntecedentesPatologicosWhereInput
  }

  export type ExamenClinicoIntraoralListRelationFilter = {
    every?: ExamenClinicoIntraoralWhereInput
    some?: ExamenClinicoIntraoralWhereInput
    none?: ExamenClinicoIntraoralWhereInput
  }

  export type AntecedentesNoPatologicosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AntecedentesPatologicosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamenClinicoIntraoralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    sexo?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    curp?: SortOrder
    correo_electronico?: SortOrder
    tipo_sangre?: SortOrder
    ocupacion?: SortOrder
    escolaridad?: SortOrder
  }

  export type ClientesAvgOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type ClientesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    sexo?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    curp?: SortOrder
    correo_electronico?: SortOrder
    tipo_sangre?: SortOrder
    ocupacion?: SortOrder
    escolaridad?: SortOrder
  }

  export type ClientesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    apellido?: SortOrder
    sexo?: SortOrder
    edad?: SortOrder
    fecha_nacimiento?: SortOrder
    domicilio?: SortOrder
    telefono?: SortOrder
    curp?: SortOrder
    correo_electronico?: SortOrder
    tipo_sangre?: SortOrder
    ocupacion?: SortOrder
    escolaridad?: SortOrder
  }

  export type ClientesSumOrderByAggregateInput = {
    id?: SortOrder
    edad?: SortOrder
  }

  export type EnumTipoEnfermedadEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEnfermedadEnum | EnumTipoEnfermedadEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEnfermedadEnum[]
    notIn?: $Enums.TipoEnfermedadEnum[]
    not?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel> | $Enums.TipoEnfermedadEnum
  }

  export type EnfermedadesCountOrderByAggregateInput = {
    id_enfermedad?: SortOrder
    tipo?: SortOrder
    otro?: SortOrder
    causas?: SortOrder
    sintomas?: SortOrder
    tratamiento?: SortOrder
  }

  export type EnfermedadesAvgOrderByAggregateInput = {
    id_enfermedad?: SortOrder
  }

  export type EnfermedadesMaxOrderByAggregateInput = {
    id_enfermedad?: SortOrder
    tipo?: SortOrder
    otro?: SortOrder
    causas?: SortOrder
    sintomas?: SortOrder
    tratamiento?: SortOrder
  }

  export type EnfermedadesMinOrderByAggregateInput = {
    id_enfermedad?: SortOrder
    tipo?: SortOrder
    otro?: SortOrder
    causas?: SortOrder
    sintomas?: SortOrder
    tratamiento?: SortOrder
  }

  export type EnfermedadesSumOrderByAggregateInput = {
    id_enfermedad?: SortOrder
  }

  export type EnumTipoEnfermedadEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEnfermedadEnum | EnumTipoEnfermedadEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEnfermedadEnum[]
    notIn?: $Enums.TipoEnfermedadEnum[]
    not?: NestedEnumTipoEnfermedadEnumWithAggregatesFilter<$PrismaModel> | $Enums.TipoEnfermedadEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel>
    _max?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel>
  }

  export type EnumSiNoEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.SiNoEnum | EnumSiNoEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SiNoEnum[]
    notIn?: $Enums.SiNoEnum[]
    not?: NestedEnumSiNoEnumFilter<$PrismaModel> | $Enums.SiNoEnum
  }

  export type ClientesRelationFilter = {
    is?: ClientesWhereInput
    isNot?: ClientesWhereInput
  }

  export type AntecedentesNoPatologicosCountOrderByAggregateInput = {
    id_paciente?: SortOrder
    tabaquismo?: SortOrder
    toxicomanias?: SortOrder
    alcoholismo?: SortOrder
    sedentarismo?: SortOrder
    cirugias?: SortOrder
    ejercicio?: SortOrder
  }

  export type AntecedentesNoPatologicosAvgOrderByAggregateInput = {
    id_paciente?: SortOrder
  }

  export type AntecedentesNoPatologicosMaxOrderByAggregateInput = {
    id_paciente?: SortOrder
    tabaquismo?: SortOrder
    toxicomanias?: SortOrder
    alcoholismo?: SortOrder
    sedentarismo?: SortOrder
    cirugias?: SortOrder
    ejercicio?: SortOrder
  }

  export type AntecedentesNoPatologicosMinOrderByAggregateInput = {
    id_paciente?: SortOrder
    tabaquismo?: SortOrder
    toxicomanias?: SortOrder
    alcoholismo?: SortOrder
    sedentarismo?: SortOrder
    cirugias?: SortOrder
    ejercicio?: SortOrder
  }

  export type AntecedentesNoPatologicosSumOrderByAggregateInput = {
    id_paciente?: SortOrder
  }

  export type EnumSiNoEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SiNoEnum | EnumSiNoEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SiNoEnum[]
    notIn?: $Enums.SiNoEnum[]
    not?: NestedEnumSiNoEnumWithAggregatesFilter<$PrismaModel> | $Enums.SiNoEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSiNoEnumFilter<$PrismaModel>
    _max?: NestedEnumSiNoEnumFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AntecedentesPatologicosCountOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    enfermedad?: SortOrder
    fecha_diagnostico?: SortOrder
    tipo_enfermedad?: SortOrder
    cronica?: SortOrder
    tratamiento?: SortOrder
    observaciones?: SortOrder
  }

  export type AntecedentesPatologicosAvgOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
  }

  export type AntecedentesPatologicosMaxOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    enfermedad?: SortOrder
    fecha_diagnostico?: SortOrder
    tipo_enfermedad?: SortOrder
    cronica?: SortOrder
    tratamiento?: SortOrder
    observaciones?: SortOrder
  }

  export type AntecedentesPatologicosMinOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
    enfermedad?: SortOrder
    fecha_diagnostico?: SortOrder
    tipo_enfermedad?: SortOrder
    cronica?: SortOrder
    tratamiento?: SortOrder
    observaciones?: SortOrder
  }

  export type AntecedentesPatologicosSumOrderByAggregateInput = {
    id?: SortOrder
    paciente_id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ExamenClinicoIntraoralCountOrderByAggregateInput = {
    id_paciente?: SortOrder
    fecha_examen?: SortOrder
    encia?: SortOrder
    lengua?: SortOrder
    paladar_duro?: SortOrder
    paladar_blando?: SortOrder
    faringe?: SortOrder
    piso_de_la_boca?: SortOrder
    reborde_residual?: SortOrder
    tipo_oclusion?: SortOrder
    observaciones?: SortOrder
  }

  export type ExamenClinicoIntraoralAvgOrderByAggregateInput = {
    id_paciente?: SortOrder
  }

  export type ExamenClinicoIntraoralMaxOrderByAggregateInput = {
    id_paciente?: SortOrder
    fecha_examen?: SortOrder
    encia?: SortOrder
    lengua?: SortOrder
    paladar_duro?: SortOrder
    paladar_blando?: SortOrder
    faringe?: SortOrder
    piso_de_la_boca?: SortOrder
    reborde_residual?: SortOrder
    tipo_oclusion?: SortOrder
    observaciones?: SortOrder
  }

  export type ExamenClinicoIntraoralMinOrderByAggregateInput = {
    id_paciente?: SortOrder
    fecha_examen?: SortOrder
    encia?: SortOrder
    lengua?: SortOrder
    paladar_duro?: SortOrder
    paladar_blando?: SortOrder
    faringe?: SortOrder
    piso_de_la_boca?: SortOrder
    reborde_residual?: SortOrder
    tipo_oclusion?: SortOrder
    observaciones?: SortOrder
  }

  export type ExamenClinicoIntraoralSumOrderByAggregateInput = {
    id_paciente?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DoctorRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type HistorialClinicoCountOrderByAggregateInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
    fecha_consulta?: SortOrder
    datos_clinicos?: SortOrder
  }

  export type HistorialClinicoAvgOrderByAggregateInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
  }

  export type HistorialClinicoMaxOrderByAggregateInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
    fecha_consulta?: SortOrder
  }

  export type HistorialClinicoMinOrderByAggregateInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
    fecha_consulta?: SortOrder
  }

  export type HistorialClinicoSumOrderByAggregateInput = {
    id?: SortOrder
    cliente_id?: SortOrder
    dentista_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type PermisoCountOrderByAggregateInput = {
    id?: SortOrder
    permiso?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PermisoMaxOrderByAggregateInput = {
    id?: SortOrder
    permiso?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoMinOrderByAggregateInput = {
    id?: SortOrder
    permiso?: SortOrder
    descripcion?: SortOrder
  }

  export type PermisoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BitacoraCountOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    usuario?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    id_registro?: SortOrder
    descripcion?: SortOrder
  }

  export type BitacoraAvgOrderByAggregateInput = {
    id?: SortOrder
    id_registro?: SortOrder
  }

  export type BitacoraMaxOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    usuario?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    id_registro?: SortOrder
    descripcion?: SortOrder
  }

  export type BitacoraMinOrderByAggregateInput = {
    id?: SortOrder
    fecha_hora?: SortOrder
    usuario?: SortOrder
    accion?: SortOrder
    tabla?: SortOrder
    id_registro?: SortOrder
    descripcion?: SortOrder
  }

  export type BitacoraSumOrderByAggregateInput = {
    id?: SortOrder
    id_registro?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UsuariosCountOrderByAggregateInput = {
    Id?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    IsAdministrator?: SortOrder
    IsDoctor?: SortOrder
    IsEmployee?: SortOrder
  }

  export type UsuariosAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    Id?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    IsAdministrator?: SortOrder
    IsDoctor?: SortOrder
    IsEmployee?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    Id?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    IsAdministrator?: SortOrder
    IsDoctor?: SortOrder
    IsEmployee?: SortOrder
  }

  export type UsuariosSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type HistorialClinicoCreateNestedManyWithoutDentistaInput = {
    create?: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput> | HistorialClinicoCreateWithoutDentistaInput[] | HistorialClinicoUncheckedCreateWithoutDentistaInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutDentistaInput | HistorialClinicoCreateOrConnectWithoutDentistaInput[]
    createMany?: HistorialClinicoCreateManyDentistaInputEnvelope
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
  }

  export type HistorialClinicoUncheckedCreateNestedManyWithoutDentistaInput = {
    create?: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput> | HistorialClinicoCreateWithoutDentistaInput[] | HistorialClinicoUncheckedCreateWithoutDentistaInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutDentistaInput | HistorialClinicoCreateOrConnectWithoutDentistaInput[]
    createMany?: HistorialClinicoCreateManyDentistaInputEnvelope
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableEnumGeneroEnumFieldUpdateOperationsInput = {
    set?: $Enums.GeneroEnum | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type HistorialClinicoUpdateManyWithoutDentistaNestedInput = {
    create?: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput> | HistorialClinicoCreateWithoutDentistaInput[] | HistorialClinicoUncheckedCreateWithoutDentistaInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutDentistaInput | HistorialClinicoCreateOrConnectWithoutDentistaInput[]
    upsert?: HistorialClinicoUpsertWithWhereUniqueWithoutDentistaInput | HistorialClinicoUpsertWithWhereUniqueWithoutDentistaInput[]
    createMany?: HistorialClinicoCreateManyDentistaInputEnvelope
    set?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    disconnect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    delete?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    update?: HistorialClinicoUpdateWithWhereUniqueWithoutDentistaInput | HistorialClinicoUpdateWithWhereUniqueWithoutDentistaInput[]
    updateMany?: HistorialClinicoUpdateManyWithWhereWithoutDentistaInput | HistorialClinicoUpdateManyWithWhereWithoutDentistaInput[]
    deleteMany?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HistorialClinicoUncheckedUpdateManyWithoutDentistaNestedInput = {
    create?: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput> | HistorialClinicoCreateWithoutDentistaInput[] | HistorialClinicoUncheckedCreateWithoutDentistaInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutDentistaInput | HistorialClinicoCreateOrConnectWithoutDentistaInput[]
    upsert?: HistorialClinicoUpsertWithWhereUniqueWithoutDentistaInput | HistorialClinicoUpsertWithWhereUniqueWithoutDentistaInput[]
    createMany?: HistorialClinicoCreateManyDentistaInputEnvelope
    set?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    disconnect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    delete?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    update?: HistorialClinicoUpdateWithWhereUniqueWithoutDentistaInput | HistorialClinicoUpdateWithWhereUniqueWithoutDentistaInput[]
    updateMany?: HistorialClinicoUpdateManyWithWhereWithoutDentistaInput | HistorialClinicoUpdateManyWithWhereWithoutDentistaInput[]
    deleteMany?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HistorialClinicoCreateNestedManyWithoutClienteInput = {
    create?: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput> | HistorialClinicoCreateWithoutClienteInput[] | HistorialClinicoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutClienteInput | HistorialClinicoCreateOrConnectWithoutClienteInput[]
    createMany?: HistorialClinicoCreateManyClienteInputEnvelope
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
  }

  export type AntecedentesNoPatologicosCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesNoPatologicosCreateWithoutPacienteInput[] | AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput[]
    createMany?: AntecedentesNoPatologicosCreateManyPacienteInputEnvelope
    connect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
  }

  export type AntecedentesPatologicosCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesPatologicosCreateWithoutPacienteInput[] | AntecedentesPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesPatologicosCreateOrConnectWithoutPacienteInput[]
    createMany?: AntecedentesPatologicosCreateManyPacienteInputEnvelope
    connect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
  }

  export type ExamenClinicoIntraoralCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput> | ExamenClinicoIntraoralCreateWithoutPacienteInput[] | ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput | ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput[]
    createMany?: ExamenClinicoIntraoralCreateManyPacienteInputEnvelope
    connect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
  }

  export type HistorialClinicoUncheckedCreateNestedManyWithoutClienteInput = {
    create?: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput> | HistorialClinicoCreateWithoutClienteInput[] | HistorialClinicoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutClienteInput | HistorialClinicoCreateOrConnectWithoutClienteInput[]
    createMany?: HistorialClinicoCreateManyClienteInputEnvelope
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
  }

  export type AntecedentesNoPatologicosUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesNoPatologicosCreateWithoutPacienteInput[] | AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput[]
    createMany?: AntecedentesNoPatologicosCreateManyPacienteInputEnvelope
    connect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
  }

  export type AntecedentesPatologicosUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesPatologicosCreateWithoutPacienteInput[] | AntecedentesPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesPatologicosCreateOrConnectWithoutPacienteInput[]
    createMany?: AntecedentesPatologicosCreateManyPacienteInputEnvelope
    connect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
  }

  export type ExamenClinicoIntraoralUncheckedCreateNestedManyWithoutPacienteInput = {
    create?: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput> | ExamenClinicoIntraoralCreateWithoutPacienteInput[] | ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput | ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput[]
    createMany?: ExamenClinicoIntraoralCreateManyPacienteInputEnvelope
    connect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
  }

  export type HistorialClinicoUpdateManyWithoutClienteNestedInput = {
    create?: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput> | HistorialClinicoCreateWithoutClienteInput[] | HistorialClinicoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutClienteInput | HistorialClinicoCreateOrConnectWithoutClienteInput[]
    upsert?: HistorialClinicoUpsertWithWhereUniqueWithoutClienteInput | HistorialClinicoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: HistorialClinicoCreateManyClienteInputEnvelope
    set?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    disconnect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    delete?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    update?: HistorialClinicoUpdateWithWhereUniqueWithoutClienteInput | HistorialClinicoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: HistorialClinicoUpdateManyWithWhereWithoutClienteInput | HistorialClinicoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
  }

  export type AntecedentesNoPatologicosUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesNoPatologicosCreateWithoutPacienteInput[] | AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput[]
    upsert?: AntecedentesNoPatologicosUpsertWithWhereUniqueWithoutPacienteInput | AntecedentesNoPatologicosUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AntecedentesNoPatologicosCreateManyPacienteInputEnvelope
    set?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    disconnect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    delete?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    connect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    update?: AntecedentesNoPatologicosUpdateWithWhereUniqueWithoutPacienteInput | AntecedentesNoPatologicosUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AntecedentesNoPatologicosUpdateManyWithWhereWithoutPacienteInput | AntecedentesNoPatologicosUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AntecedentesNoPatologicosScalarWhereInput | AntecedentesNoPatologicosScalarWhereInput[]
  }

  export type AntecedentesPatologicosUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesPatologicosCreateWithoutPacienteInput[] | AntecedentesPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesPatologicosCreateOrConnectWithoutPacienteInput[]
    upsert?: AntecedentesPatologicosUpsertWithWhereUniqueWithoutPacienteInput | AntecedentesPatologicosUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AntecedentesPatologicosCreateManyPacienteInputEnvelope
    set?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    disconnect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    delete?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    connect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    update?: AntecedentesPatologicosUpdateWithWhereUniqueWithoutPacienteInput | AntecedentesPatologicosUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AntecedentesPatologicosUpdateManyWithWhereWithoutPacienteInput | AntecedentesPatologicosUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AntecedentesPatologicosScalarWhereInput | AntecedentesPatologicosScalarWhereInput[]
  }

  export type ExamenClinicoIntraoralUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput> | ExamenClinicoIntraoralCreateWithoutPacienteInput[] | ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput | ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput[]
    upsert?: ExamenClinicoIntraoralUpsertWithWhereUniqueWithoutPacienteInput | ExamenClinicoIntraoralUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ExamenClinicoIntraoralCreateManyPacienteInputEnvelope
    set?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    disconnect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    delete?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    connect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    update?: ExamenClinicoIntraoralUpdateWithWhereUniqueWithoutPacienteInput | ExamenClinicoIntraoralUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ExamenClinicoIntraoralUpdateManyWithWhereWithoutPacienteInput | ExamenClinicoIntraoralUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ExamenClinicoIntraoralScalarWhereInput | ExamenClinicoIntraoralScalarWhereInput[]
  }

  export type HistorialClinicoUncheckedUpdateManyWithoutClienteNestedInput = {
    create?: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput> | HistorialClinicoCreateWithoutClienteInput[] | HistorialClinicoUncheckedCreateWithoutClienteInput[]
    connectOrCreate?: HistorialClinicoCreateOrConnectWithoutClienteInput | HistorialClinicoCreateOrConnectWithoutClienteInput[]
    upsert?: HistorialClinicoUpsertWithWhereUniqueWithoutClienteInput | HistorialClinicoUpsertWithWhereUniqueWithoutClienteInput[]
    createMany?: HistorialClinicoCreateManyClienteInputEnvelope
    set?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    disconnect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    delete?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    connect?: HistorialClinicoWhereUniqueInput | HistorialClinicoWhereUniqueInput[]
    update?: HistorialClinicoUpdateWithWhereUniqueWithoutClienteInput | HistorialClinicoUpdateWithWhereUniqueWithoutClienteInput[]
    updateMany?: HistorialClinicoUpdateManyWithWhereWithoutClienteInput | HistorialClinicoUpdateManyWithWhereWithoutClienteInput[]
    deleteMany?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
  }

  export type AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesNoPatologicosCreateWithoutPacienteInput[] | AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput[]
    upsert?: AntecedentesNoPatologicosUpsertWithWhereUniqueWithoutPacienteInput | AntecedentesNoPatologicosUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AntecedentesNoPatologicosCreateManyPacienteInputEnvelope
    set?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    disconnect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    delete?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    connect?: AntecedentesNoPatologicosWhereUniqueInput | AntecedentesNoPatologicosWhereUniqueInput[]
    update?: AntecedentesNoPatologicosUpdateWithWhereUniqueWithoutPacienteInput | AntecedentesNoPatologicosUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AntecedentesNoPatologicosUpdateManyWithWhereWithoutPacienteInput | AntecedentesNoPatologicosUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AntecedentesNoPatologicosScalarWhereInput | AntecedentesNoPatologicosScalarWhereInput[]
  }

  export type AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput> | AntecedentesPatologicosCreateWithoutPacienteInput[] | AntecedentesPatologicosUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: AntecedentesPatologicosCreateOrConnectWithoutPacienteInput | AntecedentesPatologicosCreateOrConnectWithoutPacienteInput[]
    upsert?: AntecedentesPatologicosUpsertWithWhereUniqueWithoutPacienteInput | AntecedentesPatologicosUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: AntecedentesPatologicosCreateManyPacienteInputEnvelope
    set?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    disconnect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    delete?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    connect?: AntecedentesPatologicosWhereUniqueInput | AntecedentesPatologicosWhereUniqueInput[]
    update?: AntecedentesPatologicosUpdateWithWhereUniqueWithoutPacienteInput | AntecedentesPatologicosUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: AntecedentesPatologicosUpdateManyWithWhereWithoutPacienteInput | AntecedentesPatologicosUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: AntecedentesPatologicosScalarWhereInput | AntecedentesPatologicosScalarWhereInput[]
  }

  export type ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteNestedInput = {
    create?: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput> | ExamenClinicoIntraoralCreateWithoutPacienteInput[] | ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput[]
    connectOrCreate?: ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput | ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput[]
    upsert?: ExamenClinicoIntraoralUpsertWithWhereUniqueWithoutPacienteInput | ExamenClinicoIntraoralUpsertWithWhereUniqueWithoutPacienteInput[]
    createMany?: ExamenClinicoIntraoralCreateManyPacienteInputEnvelope
    set?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    disconnect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    delete?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    connect?: ExamenClinicoIntraoralWhereUniqueInput | ExamenClinicoIntraoralWhereUniqueInput[]
    update?: ExamenClinicoIntraoralUpdateWithWhereUniqueWithoutPacienteInput | ExamenClinicoIntraoralUpdateWithWhereUniqueWithoutPacienteInput[]
    updateMany?: ExamenClinicoIntraoralUpdateManyWithWhereWithoutPacienteInput | ExamenClinicoIntraoralUpdateManyWithWhereWithoutPacienteInput[]
    deleteMany?: ExamenClinicoIntraoralScalarWhereInput | ExamenClinicoIntraoralScalarWhereInput[]
  }

  export type EnumTipoEnfermedadEnumFieldUpdateOperationsInput = {
    set?: $Enums.TipoEnfermedadEnum
  }

  export type ClientesCreateNestedOneWithoutAntecedentesNoPatologicosInput = {
    create?: XOR<ClientesCreateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesNoPatologicosInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutAntecedentesNoPatologicosInput
    connect?: ClientesWhereUniqueInput
  }

  export type EnumSiNoEnumFieldUpdateOperationsInput = {
    set?: $Enums.SiNoEnum
  }

  export type ClientesUpdateOneRequiredWithoutAntecedentesNoPatologicosNestedInput = {
    create?: XOR<ClientesCreateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesNoPatologicosInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutAntecedentesNoPatologicosInput
    upsert?: ClientesUpsertWithoutAntecedentesNoPatologicosInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<XOR<ClientesUpdateToOneWithWhereWithoutAntecedentesNoPatologicosInput, ClientesUpdateWithoutAntecedentesNoPatologicosInput>, ClientesUncheckedUpdateWithoutAntecedentesNoPatologicosInput>
  }

  export type ClientesCreateNestedOneWithoutAntecedentesPatologicosInput = {
    create?: XOR<ClientesCreateWithoutAntecedentesPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesPatologicosInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutAntecedentesPatologicosInput
    connect?: ClientesWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClientesUpdateOneRequiredWithoutAntecedentesPatologicosNestedInput = {
    create?: XOR<ClientesCreateWithoutAntecedentesPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesPatologicosInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutAntecedentesPatologicosInput
    upsert?: ClientesUpsertWithoutAntecedentesPatologicosInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<XOR<ClientesUpdateToOneWithWhereWithoutAntecedentesPatologicosInput, ClientesUpdateWithoutAntecedentesPatologicosInput>, ClientesUncheckedUpdateWithoutAntecedentesPatologicosInput>
  }

  export type ClientesCreateNestedOneWithoutExamenesClinicosIntraoralesInput = {
    create?: XOR<ClientesCreateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedCreateWithoutExamenesClinicosIntraoralesInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutExamenesClinicosIntraoralesInput
    connect?: ClientesWhereUniqueInput
  }

  export type ClientesUpdateOneRequiredWithoutExamenesClinicosIntraoralesNestedInput = {
    create?: XOR<ClientesCreateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedCreateWithoutExamenesClinicosIntraoralesInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutExamenesClinicosIntraoralesInput
    upsert?: ClientesUpsertWithoutExamenesClinicosIntraoralesInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<XOR<ClientesUpdateToOneWithWhereWithoutExamenesClinicosIntraoralesInput, ClientesUpdateWithoutExamenesClinicosIntraoralesInput>, ClientesUncheckedUpdateWithoutExamenesClinicosIntraoralesInput>
  }

  export type ClientesCreateNestedOneWithoutHistorial_clinicoInput = {
    create?: XOR<ClientesCreateWithoutHistorial_clinicoInput, ClientesUncheckedCreateWithoutHistorial_clinicoInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutHistorial_clinicoInput
    connect?: ClientesWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutHistoriales_clinicosInput = {
    create?: XOR<DoctorCreateWithoutHistoriales_clinicosInput, DoctorUncheckedCreateWithoutHistoriales_clinicosInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutHistoriales_clinicosInput
    connect?: DoctorWhereUniqueInput
  }

  export type ClientesUpdateOneRequiredWithoutHistorial_clinicoNestedInput = {
    create?: XOR<ClientesCreateWithoutHistorial_clinicoInput, ClientesUncheckedCreateWithoutHistorial_clinicoInput>
    connectOrCreate?: ClientesCreateOrConnectWithoutHistorial_clinicoInput
    upsert?: ClientesUpsertWithoutHistorial_clinicoInput
    connect?: ClientesWhereUniqueInput
    update?: XOR<XOR<ClientesUpdateToOneWithWhereWithoutHistorial_clinicoInput, ClientesUpdateWithoutHistorial_clinicoInput>, ClientesUncheckedUpdateWithoutHistorial_clinicoInput>
  }

  export type DoctorUpdateOneRequiredWithoutHistoriales_clinicosNestedInput = {
    create?: XOR<DoctorCreateWithoutHistoriales_clinicosInput, DoctorUncheckedCreateWithoutHistoriales_clinicosInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutHistoriales_clinicosInput
    upsert?: DoctorUpsertWithoutHistoriales_clinicosInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutHistoriales_clinicosInput, DoctorUpdateWithoutHistoriales_clinicosInput>, DoctorUncheckedUpdateWithoutHistoriales_clinicosInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumGeneroEnumNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneroEnum | EnumGeneroEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GeneroEnum[] | null
    notIn?: $Enums.GeneroEnum[] | null
    not?: NestedEnumGeneroEnumNullableFilter<$PrismaModel> | $Enums.GeneroEnum | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumGeneroEnumNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.GeneroEnum | EnumGeneroEnumFieldRefInput<$PrismaModel> | null
    in?: $Enums.GeneroEnum[] | null
    notIn?: $Enums.GeneroEnum[] | null
    not?: NestedEnumGeneroEnumNullableWithAggregatesFilter<$PrismaModel> | $Enums.GeneroEnum | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGeneroEnumNullableFilter<$PrismaModel>
    _max?: NestedEnumGeneroEnumNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTipoEnfermedadEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEnfermedadEnum | EnumTipoEnfermedadEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEnfermedadEnum[]
    notIn?: $Enums.TipoEnfermedadEnum[]
    not?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel> | $Enums.TipoEnfermedadEnum
  }

  export type NestedEnumTipoEnfermedadEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEnfermedadEnum | EnumTipoEnfermedadEnumFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEnfermedadEnum[]
    notIn?: $Enums.TipoEnfermedadEnum[]
    not?: NestedEnumTipoEnfermedadEnumWithAggregatesFilter<$PrismaModel> | $Enums.TipoEnfermedadEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel>
    _max?: NestedEnumTipoEnfermedadEnumFilter<$PrismaModel>
  }

  export type NestedEnumSiNoEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.SiNoEnum | EnumSiNoEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SiNoEnum[]
    notIn?: $Enums.SiNoEnum[]
    not?: NestedEnumSiNoEnumFilter<$PrismaModel> | $Enums.SiNoEnum
  }

  export type NestedEnumSiNoEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SiNoEnum | EnumSiNoEnumFieldRefInput<$PrismaModel>
    in?: $Enums.SiNoEnum[]
    notIn?: $Enums.SiNoEnum[]
    not?: NestedEnumSiNoEnumWithAggregatesFilter<$PrismaModel> | $Enums.SiNoEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSiNoEnumFilter<$PrismaModel>
    _max?: NestedEnumSiNoEnumFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type HistorialClinicoCreateWithoutDentistaInput = {
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
    cliente: ClientesCreateNestedOneWithoutHistorial_clinicoInput
  }

  export type HistorialClinicoUncheckedCreateWithoutDentistaInput = {
    id?: number
    cliente_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoCreateOrConnectWithoutDentistaInput = {
    where: HistorialClinicoWhereUniqueInput
    create: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput>
  }

  export type HistorialClinicoCreateManyDentistaInputEnvelope = {
    data: HistorialClinicoCreateManyDentistaInput | HistorialClinicoCreateManyDentistaInput[]
    skipDuplicates?: boolean
  }

  export type HistorialClinicoUpsertWithWhereUniqueWithoutDentistaInput = {
    where: HistorialClinicoWhereUniqueInput
    update: XOR<HistorialClinicoUpdateWithoutDentistaInput, HistorialClinicoUncheckedUpdateWithoutDentistaInput>
    create: XOR<HistorialClinicoCreateWithoutDentistaInput, HistorialClinicoUncheckedCreateWithoutDentistaInput>
  }

  export type HistorialClinicoUpdateWithWhereUniqueWithoutDentistaInput = {
    where: HistorialClinicoWhereUniqueInput
    data: XOR<HistorialClinicoUpdateWithoutDentistaInput, HistorialClinicoUncheckedUpdateWithoutDentistaInput>
  }

  export type HistorialClinicoUpdateManyWithWhereWithoutDentistaInput = {
    where: HistorialClinicoScalarWhereInput
    data: XOR<HistorialClinicoUpdateManyMutationInput, HistorialClinicoUncheckedUpdateManyWithoutDentistaInput>
  }

  export type HistorialClinicoScalarWhereInput = {
    AND?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
    OR?: HistorialClinicoScalarWhereInput[]
    NOT?: HistorialClinicoScalarWhereInput | HistorialClinicoScalarWhereInput[]
    id?: IntFilter<"HistorialClinico"> | number
    cliente_id?: IntFilter<"HistorialClinico"> | number
    dentista_id?: IntFilter<"HistorialClinico"> | number
    fecha_consulta?: DateTimeFilter<"HistorialClinico"> | Date | string
    datos_clinicos?: JsonFilter<"HistorialClinico">
  }

  export type HistorialClinicoCreateWithoutClienteInput = {
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
    dentista: DoctorCreateNestedOneWithoutHistoriales_clinicosInput
  }

  export type HistorialClinicoUncheckedCreateWithoutClienteInput = {
    id?: number
    dentista_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoCreateOrConnectWithoutClienteInput = {
    where: HistorialClinicoWhereUniqueInput
    create: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput>
  }

  export type HistorialClinicoCreateManyClienteInputEnvelope = {
    data: HistorialClinicoCreateManyClienteInput | HistorialClinicoCreateManyClienteInput[]
    skipDuplicates?: boolean
  }

  export type AntecedentesNoPatologicosCreateWithoutPacienteInput = {
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
  }

  export type AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput = {
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
  }

  export type AntecedentesNoPatologicosCreateOrConnectWithoutPacienteInput = {
    where: AntecedentesNoPatologicosWhereUniqueInput
    create: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput>
  }

  export type AntecedentesNoPatologicosCreateManyPacienteInputEnvelope = {
    data: AntecedentesNoPatologicosCreateManyPacienteInput | AntecedentesNoPatologicosCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type AntecedentesPatologicosCreateWithoutPacienteInput = {
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
  }

  export type AntecedentesPatologicosUncheckedCreateWithoutPacienteInput = {
    id?: number
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
  }

  export type AntecedentesPatologicosCreateOrConnectWithoutPacienteInput = {
    where: AntecedentesPatologicosWhereUniqueInput
    create: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput>
  }

  export type AntecedentesPatologicosCreateManyPacienteInputEnvelope = {
    data: AntecedentesPatologicosCreateManyPacienteInput | AntecedentesPatologicosCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type ExamenClinicoIntraoralCreateWithoutPacienteInput = {
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
  }

  export type ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput = {
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
  }

  export type ExamenClinicoIntraoralCreateOrConnectWithoutPacienteInput = {
    where: ExamenClinicoIntraoralWhereUniqueInput
    create: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput>
  }

  export type ExamenClinicoIntraoralCreateManyPacienteInputEnvelope = {
    data: ExamenClinicoIntraoralCreateManyPacienteInput | ExamenClinicoIntraoralCreateManyPacienteInput[]
    skipDuplicates?: boolean
  }

  export type HistorialClinicoUpsertWithWhereUniqueWithoutClienteInput = {
    where: HistorialClinicoWhereUniqueInput
    update: XOR<HistorialClinicoUpdateWithoutClienteInput, HistorialClinicoUncheckedUpdateWithoutClienteInput>
    create: XOR<HistorialClinicoCreateWithoutClienteInput, HistorialClinicoUncheckedCreateWithoutClienteInput>
  }

  export type HistorialClinicoUpdateWithWhereUniqueWithoutClienteInput = {
    where: HistorialClinicoWhereUniqueInput
    data: XOR<HistorialClinicoUpdateWithoutClienteInput, HistorialClinicoUncheckedUpdateWithoutClienteInput>
  }

  export type HistorialClinicoUpdateManyWithWhereWithoutClienteInput = {
    where: HistorialClinicoScalarWhereInput
    data: XOR<HistorialClinicoUpdateManyMutationInput, HistorialClinicoUncheckedUpdateManyWithoutClienteInput>
  }

  export type AntecedentesNoPatologicosUpsertWithWhereUniqueWithoutPacienteInput = {
    where: AntecedentesNoPatologicosWhereUniqueInput
    update: XOR<AntecedentesNoPatologicosUpdateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedUpdateWithoutPacienteInput>
    create: XOR<AntecedentesNoPatologicosCreateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedCreateWithoutPacienteInput>
  }

  export type AntecedentesNoPatologicosUpdateWithWhereUniqueWithoutPacienteInput = {
    where: AntecedentesNoPatologicosWhereUniqueInput
    data: XOR<AntecedentesNoPatologicosUpdateWithoutPacienteInput, AntecedentesNoPatologicosUncheckedUpdateWithoutPacienteInput>
  }

  export type AntecedentesNoPatologicosUpdateManyWithWhereWithoutPacienteInput = {
    where: AntecedentesNoPatologicosScalarWhereInput
    data: XOR<AntecedentesNoPatologicosUpdateManyMutationInput, AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteInput>
  }

  export type AntecedentesNoPatologicosScalarWhereInput = {
    AND?: AntecedentesNoPatologicosScalarWhereInput | AntecedentesNoPatologicosScalarWhereInput[]
    OR?: AntecedentesNoPatologicosScalarWhereInput[]
    NOT?: AntecedentesNoPatologicosScalarWhereInput | AntecedentesNoPatologicosScalarWhereInput[]
    id_paciente?: IntFilter<"AntecedentesNoPatologicos"> | number
    tabaquismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFilter<"AntecedentesNoPatologicos"> | $Enums.SiNoEnum
    cirugias?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
    ejercicio?: StringNullableFilter<"AntecedentesNoPatologicos"> | string | null
  }

  export type AntecedentesPatologicosUpsertWithWhereUniqueWithoutPacienteInput = {
    where: AntecedentesPatologicosWhereUniqueInput
    update: XOR<AntecedentesPatologicosUpdateWithoutPacienteInput, AntecedentesPatologicosUncheckedUpdateWithoutPacienteInput>
    create: XOR<AntecedentesPatologicosCreateWithoutPacienteInput, AntecedentesPatologicosUncheckedCreateWithoutPacienteInput>
  }

  export type AntecedentesPatologicosUpdateWithWhereUniqueWithoutPacienteInput = {
    where: AntecedentesPatologicosWhereUniqueInput
    data: XOR<AntecedentesPatologicosUpdateWithoutPacienteInput, AntecedentesPatologicosUncheckedUpdateWithoutPacienteInput>
  }

  export type AntecedentesPatologicosUpdateManyWithWhereWithoutPacienteInput = {
    where: AntecedentesPatologicosScalarWhereInput
    data: XOR<AntecedentesPatologicosUpdateManyMutationInput, AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteInput>
  }

  export type AntecedentesPatologicosScalarWhereInput = {
    AND?: AntecedentesPatologicosScalarWhereInput | AntecedentesPatologicosScalarWhereInput[]
    OR?: AntecedentesPatologicosScalarWhereInput[]
    NOT?: AntecedentesPatologicosScalarWhereInput | AntecedentesPatologicosScalarWhereInput[]
    id?: IntFilter<"AntecedentesPatologicos"> | number
    paciente_id?: IntFilter<"AntecedentesPatologicos"> | number
    enfermedad?: StringFilter<"AntecedentesPatologicos"> | string
    fecha_diagnostico?: DateTimeFilter<"AntecedentesPatologicos"> | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFilter<"AntecedentesPatologicos"> | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFilter<"AntecedentesPatologicos"> | $Enums.SiNoEnum
    tratamiento?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
    observaciones?: StringNullableFilter<"AntecedentesPatologicos"> | string | null
  }

  export type ExamenClinicoIntraoralUpsertWithWhereUniqueWithoutPacienteInput = {
    where: ExamenClinicoIntraoralWhereUniqueInput
    update: XOR<ExamenClinicoIntraoralUpdateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedUpdateWithoutPacienteInput>
    create: XOR<ExamenClinicoIntraoralCreateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedCreateWithoutPacienteInput>
  }

  export type ExamenClinicoIntraoralUpdateWithWhereUniqueWithoutPacienteInput = {
    where: ExamenClinicoIntraoralWhereUniqueInput
    data: XOR<ExamenClinicoIntraoralUpdateWithoutPacienteInput, ExamenClinicoIntraoralUncheckedUpdateWithoutPacienteInput>
  }

  export type ExamenClinicoIntraoralUpdateManyWithWhereWithoutPacienteInput = {
    where: ExamenClinicoIntraoralScalarWhereInput
    data: XOR<ExamenClinicoIntraoralUpdateManyMutationInput, ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteInput>
  }

  export type ExamenClinicoIntraoralScalarWhereInput = {
    AND?: ExamenClinicoIntraoralScalarWhereInput | ExamenClinicoIntraoralScalarWhereInput[]
    OR?: ExamenClinicoIntraoralScalarWhereInput[]
    NOT?: ExamenClinicoIntraoralScalarWhereInput | ExamenClinicoIntraoralScalarWhereInput[]
    id_paciente?: IntFilter<"ExamenClinicoIntraoral"> | number
    fecha_examen?: DateTimeFilter<"ExamenClinicoIntraoral"> | Date | string
    encia?: StringFilter<"ExamenClinicoIntraoral"> | string
    lengua?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_duro?: StringFilter<"ExamenClinicoIntraoral"> | string
    paladar_blando?: StringFilter<"ExamenClinicoIntraoral"> | string
    faringe?: StringFilter<"ExamenClinicoIntraoral"> | string
    piso_de_la_boca?: StringFilter<"ExamenClinicoIntraoral"> | string
    reborde_residual?: StringFilter<"ExamenClinicoIntraoral"> | string
    tipo_oclusion?: StringFilter<"ExamenClinicoIntraoral"> | string
    observaciones?: StringNullableFilter<"ExamenClinicoIntraoral"> | string | null
  }

  export type ClientesCreateWithoutAntecedentesNoPatologicosInput = {
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoCreateNestedManyWithoutClienteInput
    antecedentesPatologicos?: AntecedentesPatologicosCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUncheckedCreateWithoutAntecedentesNoPatologicosInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoUncheckedCreateNestedManyWithoutClienteInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type ClientesCreateOrConnectWithoutAntecedentesNoPatologicosInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesNoPatologicosInput>
  }

  export type ClientesUpsertWithoutAntecedentesNoPatologicosInput = {
    update: XOR<ClientesUpdateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedUpdateWithoutAntecedentesNoPatologicosInput>
    create: XOR<ClientesCreateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesNoPatologicosInput>
    where?: ClientesWhereInput
  }

  export type ClientesUpdateToOneWithWhereWithoutAntecedentesNoPatologicosInput = {
    where?: ClientesWhereInput
    data: XOR<ClientesUpdateWithoutAntecedentesNoPatologicosInput, ClientesUncheckedUpdateWithoutAntecedentesNoPatologicosInput>
  }

  export type ClientesUpdateWithoutAntecedentesNoPatologicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUpdateManyWithoutClienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesUncheckedUpdateWithoutAntecedentesNoPatologicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUncheckedUpdateManyWithoutClienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesCreateWithoutAntecedentesPatologicosInput = {
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUncheckedCreateWithoutAntecedentesPatologicosInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoUncheckedCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type ClientesCreateOrConnectWithoutAntecedentesPatologicosInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutAntecedentesPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesPatologicosInput>
  }

  export type ClientesUpsertWithoutAntecedentesPatologicosInput = {
    update: XOR<ClientesUpdateWithoutAntecedentesPatologicosInput, ClientesUncheckedUpdateWithoutAntecedentesPatologicosInput>
    create: XOR<ClientesCreateWithoutAntecedentesPatologicosInput, ClientesUncheckedCreateWithoutAntecedentesPatologicosInput>
    where?: ClientesWhereInput
  }

  export type ClientesUpdateToOneWithWhereWithoutAntecedentesPatologicosInput = {
    where?: ClientesWhereInput
    data: XOR<ClientesUpdateWithoutAntecedentesPatologicosInput, ClientesUncheckedUpdateWithoutAntecedentesPatologicosInput>
  }

  export type ClientesUpdateWithoutAntecedentesPatologicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesUncheckedUpdateWithoutAntecedentesPatologicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUncheckedUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesCreateWithoutExamenesClinicosIntraoralesInput = {
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUncheckedCreateWithoutExamenesClinicosIntraoralesInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    historial_clinico?: HistorialClinicoUncheckedCreateNestedManyWithoutClienteInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type ClientesCreateOrConnectWithoutExamenesClinicosIntraoralesInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedCreateWithoutExamenesClinicosIntraoralesInput>
  }

  export type ClientesUpsertWithoutExamenesClinicosIntraoralesInput = {
    update: XOR<ClientesUpdateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedUpdateWithoutExamenesClinicosIntraoralesInput>
    create: XOR<ClientesCreateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedCreateWithoutExamenesClinicosIntraoralesInput>
    where?: ClientesWhereInput
  }

  export type ClientesUpdateToOneWithWhereWithoutExamenesClinicosIntraoralesInput = {
    where?: ClientesWhereInput
    data: XOR<ClientesUpdateWithoutExamenesClinicosIntraoralesInput, ClientesUncheckedUpdateWithoutExamenesClinicosIntraoralesInput>
  }

  export type ClientesUpdateWithoutExamenesClinicosIntraoralesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesUncheckedUpdateWithoutExamenesClinicosIntraoralesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    historial_clinico?: HistorialClinicoUncheckedUpdateManyWithoutClienteNestedInput
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesCreateWithoutHistorial_clinicoInput = {
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    antecedentesNoPatologicos?: AntecedentesNoPatologicosCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralCreateNestedManyWithoutPacienteInput
  }

  export type ClientesUncheckedCreateWithoutHistorial_clinicoInput = {
    id?: number
    nombre: string
    apellido: string
    sexo: string
    edad: number
    fecha_nacimiento?: Date | string | null
    domicilio?: string | null
    telefono?: string | null
    curp: string
    correo_electronico?: string | null
    tipo_sangre: string
    ocupacion: string
    escolaridad: string
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedCreateNestedManyWithoutPacienteInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedCreateNestedManyWithoutPacienteInput
  }

  export type ClientesCreateOrConnectWithoutHistorial_clinicoInput = {
    where: ClientesWhereUniqueInput
    create: XOR<ClientesCreateWithoutHistorial_clinicoInput, ClientesUncheckedCreateWithoutHistorial_clinicoInput>
  }

  export type DoctorCreateWithoutHistoriales_clinicosInput = {
    nombre: string
    apellido: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    especialidad?: string | null
    direccion?: string | null
    telefono?: string | null
    celular?: string | null
    curp?: string | null
    cedula?: string | null
    sexo?: string | null
    licencia_medica?: string | null
    correo_electronico?: string | null
  }

  export type DoctorUncheckedCreateWithoutHistoriales_clinicosInput = {
    id?: number
    nombre: string
    apellido: string
    edad?: number | null
    fecha_nacimiento?: Date | string | null
    genero?: $Enums.GeneroEnum | null
    especialidad?: string | null
    direccion?: string | null
    telefono?: string | null
    celular?: string | null
    curp?: string | null
    cedula?: string | null
    sexo?: string | null
    licencia_medica?: string | null
    correo_electronico?: string | null
  }

  export type DoctorCreateOrConnectWithoutHistoriales_clinicosInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutHistoriales_clinicosInput, DoctorUncheckedCreateWithoutHistoriales_clinicosInput>
  }

  export type ClientesUpsertWithoutHistorial_clinicoInput = {
    update: XOR<ClientesUpdateWithoutHistorial_clinicoInput, ClientesUncheckedUpdateWithoutHistorial_clinicoInput>
    create: XOR<ClientesCreateWithoutHistorial_clinicoInput, ClientesUncheckedCreateWithoutHistorial_clinicoInput>
    where?: ClientesWhereInput
  }

  export type ClientesUpdateToOneWithWhereWithoutHistorial_clinicoInput = {
    where?: ClientesWhereInput
    data: XOR<ClientesUpdateWithoutHistorial_clinicoInput, ClientesUncheckedUpdateWithoutHistorial_clinicoInput>
  }

  export type ClientesUpdateWithoutHistorial_clinicoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUpdateManyWithoutPacienteNestedInput
  }

  export type ClientesUncheckedUpdateWithoutHistorial_clinicoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    sexo?: StringFieldUpdateOperationsInput | string
    edad?: IntFieldUpdateOperationsInput | number
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    domicilio?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: StringFieldUpdateOperationsInput | string
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_sangre?: StringFieldUpdateOperationsInput | string
    ocupacion?: StringFieldUpdateOperationsInput | string
    escolaridad?: StringFieldUpdateOperationsInput | string
    antecedentesNoPatologicos?: AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    antecedentesPatologicos?: AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteNestedInput
    examenesClinicosIntraorales?: ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteNestedInput
  }

  export type DoctorUpsertWithoutHistoriales_clinicosInput = {
    update: XOR<DoctorUpdateWithoutHistoriales_clinicosInput, DoctorUncheckedUpdateWithoutHistoriales_clinicosInput>
    create: XOR<DoctorCreateWithoutHistoriales_clinicosInput, DoctorUncheckedCreateWithoutHistoriales_clinicosInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutHistoriales_clinicosInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutHistoriales_clinicosInput, DoctorUncheckedUpdateWithoutHistoriales_clinicosInput>
  }

  export type DoctorUpdateWithoutHistoriales_clinicosInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DoctorUncheckedUpdateWithoutHistoriales_clinicosInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    apellido?: StringFieldUpdateOperationsInput | string
    edad?: NullableIntFieldUpdateOperationsInput | number | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    genero?: NullableEnumGeneroEnumFieldUpdateOperationsInput | $Enums.GeneroEnum | null
    especialidad?: NullableStringFieldUpdateOperationsInput | string | null
    direccion?: NullableStringFieldUpdateOperationsInput | string | null
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    celular?: NullableStringFieldUpdateOperationsInput | string | null
    curp?: NullableStringFieldUpdateOperationsInput | string | null
    cedula?: NullableStringFieldUpdateOperationsInput | string | null
    sexo?: NullableStringFieldUpdateOperationsInput | string | null
    licencia_medica?: NullableStringFieldUpdateOperationsInput | string | null
    correo_electronico?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HistorialClinicoCreateManyDentistaInput = {
    id?: number
    cliente_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUpdateWithoutDentistaInput = {
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
    cliente?: ClientesUpdateOneRequiredWithoutHistorial_clinicoNestedInput
  }

  export type HistorialClinicoUncheckedUpdateWithoutDentistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliente_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUncheckedUpdateManyWithoutDentistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    cliente_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoCreateManyClienteInput = {
    id?: number
    dentista_id: number
    fecha_consulta: Date | string
    datos_clinicos: JsonNullValueInput | InputJsonValue
  }

  export type AntecedentesNoPatologicosCreateManyPacienteInput = {
    tabaquismo: $Enums.SiNoEnum
    toxicomanias: $Enums.SiNoEnum
    alcoholismo: $Enums.SiNoEnum
    sedentarismo: $Enums.SiNoEnum
    cirugias?: string | null
    ejercicio?: string | null
  }

  export type AntecedentesPatologicosCreateManyPacienteInput = {
    id?: number
    enfermedad: string
    fecha_diagnostico: Date | string
    tipo_enfermedad: $Enums.TipoEnfermedadEnum
    cronica: $Enums.SiNoEnum
    tratamiento?: string | null
    observaciones?: string | null
  }

  export type ExamenClinicoIntraoralCreateManyPacienteInput = {
    fecha_examen: Date | string
    encia: string
    lengua: string
    paladar_duro: string
    paladar_blando: string
    faringe: string
    piso_de_la_boca: string
    reborde_residual: string
    tipo_oclusion: string
    observaciones?: string | null
  }

  export type HistorialClinicoUpdateWithoutClienteInput = {
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
    dentista?: DoctorUpdateOneRequiredWithoutHistoriales_clinicosNestedInput
  }

  export type HistorialClinicoUncheckedUpdateWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    dentista_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type HistorialClinicoUncheckedUpdateManyWithoutClienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    dentista_id?: IntFieldUpdateOperationsInput | number
    fecha_consulta?: DateTimeFieldUpdateOperationsInput | Date | string
    datos_clinicos?: JsonNullValueInput | InputJsonValue
  }

  export type AntecedentesNoPatologicosUpdateWithoutPacienteInput = {
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesNoPatologicosUncheckedUpdateWithoutPacienteInput = {
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesNoPatologicosUncheckedUpdateManyWithoutPacienteInput = {
    tabaquismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    toxicomanias?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    alcoholismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    sedentarismo?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    cirugias?: NullableStringFieldUpdateOperationsInput | string | null
    ejercicio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosUpdateWithoutPacienteInput = {
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosUncheckedUpdateWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AntecedentesPatologicosUncheckedUpdateManyWithoutPacienteInput = {
    id?: IntFieldUpdateOperationsInput | number
    enfermedad?: StringFieldUpdateOperationsInput | string
    fecha_diagnostico?: DateTimeFieldUpdateOperationsInput | Date | string
    tipo_enfermedad?: EnumTipoEnfermedadEnumFieldUpdateOperationsInput | $Enums.TipoEnfermedadEnum
    cronica?: EnumSiNoEnumFieldUpdateOperationsInput | $Enums.SiNoEnum
    tratamiento?: NullableStringFieldUpdateOperationsInput | string | null
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralUpdateWithoutPacienteInput = {
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralUncheckedUpdateWithoutPacienteInput = {
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ExamenClinicoIntraoralUncheckedUpdateManyWithoutPacienteInput = {
    fecha_examen?: DateTimeFieldUpdateOperationsInput | Date | string
    encia?: StringFieldUpdateOperationsInput | string
    lengua?: StringFieldUpdateOperationsInput | string
    paladar_duro?: StringFieldUpdateOperationsInput | string
    paladar_blando?: StringFieldUpdateOperationsInput | string
    faringe?: StringFieldUpdateOperationsInput | string
    piso_de_la_boca?: StringFieldUpdateOperationsInput | string
    reborde_residual?: StringFieldUpdateOperationsInput | string
    tipo_oclusion?: StringFieldUpdateOperationsInput | string
    observaciones?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use DoctorCountOutputTypeDefaultArgs instead
     */
    export type DoctorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientesCountOutputTypeDefaultArgs instead
     */
    export type ClientesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorDefaultArgs instead
     */
    export type DoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmpleadoDefaultArgs instead
     */
    export type EmpleadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmpleadoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientesDefaultArgs instead
     */
    export type ClientesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EnfermedadesDefaultArgs instead
     */
    export type EnfermedadesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EnfermedadesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AntecedentesNoPatologicosDefaultArgs instead
     */
    export type AntecedentesNoPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AntecedentesNoPatologicosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AntecedentesPatologicosDefaultArgs instead
     */
    export type AntecedentesPatologicosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AntecedentesPatologicosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamenClinicoIntraoralDefaultArgs instead
     */
    export type ExamenClinicoIntraoralArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamenClinicoIntraoralDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialClinicoDefaultArgs instead
     */
    export type HistorialClinicoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialClinicoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermisoDefaultArgs instead
     */
    export type PermisoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermisoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BitacoraDefaultArgs instead
     */
    export type BitacoraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BitacoraDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuariosDefaultArgs instead
     */
    export type UsuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuariosDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}